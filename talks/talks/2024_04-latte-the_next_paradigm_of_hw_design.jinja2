{% extends "base/base.jinja2" %}

{# HTML title #}
{% set webpage_title = "Chisel/Chipyard Demo + The Next Paradigm of SoC Design" %}
{# Short description #}
{% set description = "" %}
{# List of authors #}
{% set author = "Joonho Whangbo, Vighnesh Iyer" %}
{# Change ‘venue’ to a conference or workshop name if any #}
{% set venue = "LATTE 2024" %}
{# Publication info (hidden by default) #}
{% set pub_datetime_iso = "2024-04-29" %}
{% set pub_date = "April 29, 2024" %}

{% set rightarrow = "⮕" %}

{# Custom styles and JS for a particular talk #}
{% block custom_head %}
<style>
.reveal table.old_paradigm_table {
  width: 100%;
  font-size: 60%;
  border-collapse: separate;
  border-spacing: 0.1rem;
  margin-bottom: 1rem;
  tr > th {
    text-align:center;
    border: none;
  }
  tr > td {
      border: 2px solid black !important;
      border-radius: 5px;
  }
  tbody tr td {
      width: 16.6666%;
      height: 1rem;
      text-align: center;
      vertical-align: middle;
  }
  tbody tr th {
      vertical-align: middle;
  }
  tbody tr:nth-child(3) td:nth-child(3) {
  }
}
.reveal table.old_paradigm_table.new.visible {
  border-spacing: 0rem;
  tr > td {
    border-radius: 0;
    border: 0 !important;
  }
  tbody tr:nth-child(1) td {
      background: #34548a !important;
  }
  tbody tr:nth-child(2) td {
      background: #0f4b6e !important;
  }
  tbody tr:nth-child(3) td {
      background: #5a4a78 !important;
  }
}
</style>
{% endblock %}

{% block theme %}
import '/themes/tokyonight-light.scss'
import 'highlight.js/styles/tokyo-night-dark.css'
{% endblock %}

{% block slides %}
<script type="module">
import Reveal from 'reveal.js';
Reveal.on( 'fragmentshown', event => {
  // event.fragment = the fragment DOM element
  var line_numbers = event.fragment.dataset.lineNumbers;
  var elem1 = document.getElementById("special1");
  var elem2 = document.getElementById("special2");
  if (line_numbers && line_numbers == "8,13,14,15,18,19") {
    elem1.style.opacity = 1;
    elem1.style.visibility = 'inherit';
  }
  if (line_numbers && line_numbers == "42") {
    elem1.style.opacity = 0;
    elem1.style.visibility = 'hidden';
    elem2.style.opacity = 1;
    elem2.style.visibility = 'inherit';
  }
} );
Reveal.on( 'fragmenthidden', event => {
  // event.fragment = the fragment DOM element
  var line_numbers = event.fragment.dataset.lineNumbers;
  var elem1 = document.getElementById("special1");
  var elem2 = document.getElementById("special2");
  if (line_numbers && line_numbers == "8,13,14,15,18,19") {
    elem1.style.opacity = 0;
    elem1.style.visibility = 'hidden';
  }
  if (line_numbers && line_numbers == "42") {
    elem1.style.opacity = 1;
    elem1.style.visibility = 'inherit';
    elem2.style.opacity = 0;
    elem2.style.visibility = 'hidden';
  }
} );
</script>

<section>
  <section class="center">
    <a href="https://github.com/ucb-bar">
      <img src="./figs/logos/BAR_vertical_logo.svg" class="image" style="height: 100px;">
    </a>
    <a href="https://github.com/ucb-bar/chipyard">
      <img src="./figs/logos/chipyard_logo.svg" class="image" style="height: 100px;">
    </a>
    <h2 class="fragment">The Next Paradigm of SoC Design</h2>
    <h3>Chipyard Overview + Calyx Integration Demo</h3>
    <h4 style="font-weight:normal;">
      Joonho Whangbo, Vighnesh Iyer, Sophia Shao, Krste Asanović, Bora Nikolić (UC Berkeley)
    </h4>
    <h5 style="font-weight:normal;">
      LATTE 2024
    </h5>
  </section>
  <section>
    <h2>Talk Overview</h2>
    <ol>
      <li class="fragment">The existing paradigm of hardware design</li>
      <li class="fragment">What could come next? A view of the next paradigm of hardware design</li>
      <li class="fragment">Recent efforts to build the next paradigm
        <ul>
          <li class="fragment">New HDLs and design abstractions</li>
          <li class="fragment">New simulators</li>
          <li class="fragment">New SoC design frameworks</li>
        </ul>
      </li>
      <li class="fragment">What's still missing? Why are we not in the new age of hardware design?
        <ul>
          <li>It's a lot more than just the frontend language: PPA iteration cycle, verification, other stuff</li>
        </ul>
      </li>
      <li class="fragment">A sketch of what matters to hardware designers and our broad vision

      </li>
    </ol>
  </section>
</section>

<section>
  <section class="center">
    <h2>The Current Paradigm of Hardware Design</h2>

    <div class="center fragment">
      <img width="50%" class="image no-margin" src="./figs/latte24/current-paradigm.svg" />
    </div>

    <ol>
      <li class="fragment"><strong class="red">Slow iteration cycle</strong>: minutes to hours for evaluating a change</li>
      <li class="fragment"><strong class="red">One abstraction at a time</strong>: Coarse-grained integration of multiple design abstractions limits the productivity benefits of each one</li>
      <li class="fragment"><strong class="red">Loss of semantics</strong>: RTL is the "narrow waist" in the stack; higher-level semantics are stripped</li>
    </ol>
  </section>

  <!--<section>
    <h2>Rapid Iteration Across the Design Flow</h2>

    <div class="container image no-padding no-margin" style="grid-template-columns: 1fr 1fr;">
      <div class="fragment"><img width="60%" src="./figs/latte24/livesynth.png" /></div>
      <div class="fragment"><img src="./figs/latte24/livehd.png" /></div>
      <p><em>Modified image of iteration speeds. Make it clear that an fine-grained accuracy vs fidelity tradeoff is possible.</em></p>
    </div>
    <div class="center">
      <figcaption class="fragment small">LiveSynth and LiveHD make strong drive towards rapid iteration.</figcaption>
    </div>

    <ul>
      <li class="fragment">Focus not only on performance (throughput) of existing frontend + simulation tools, but also on <em>startup latency</em></li>
      <li class="fragment">It's a lot more than just the frontend language: PPA evaluation, verification, and simulation is critical</li>
      <li><em>Call out LiveHD, LiveSim, LiveSynth for being the only works that tackle this critical problem</em></li>
    </ul>
  </section>-->

  <section>
    <div style="position: relative;">
    <h2>1. <span class="red">Slow Iteration Cycle</span></h2>
    <img class="image no-margin" style="position:absolute; top: 0; right: 0; transform-origin: top right; transform: scale(1); padding: 0.3rem; width: 20%; z-index: 1;" src="./figs/latte24/current-paradigm.svg" />

    <div class="center">
      <img class="image no-margin fragment" style="z-index:-9999;" src="./figs/dynamic/latte24/iteration_speeds.svg" />
      <!--Image of iteration speeds as they exist currently. few minutes from design change to elab (for Chipyard), 10s of minutes for HLS. time for RTL sim + eval. time for firesim fpga eval. time for PD flow for power/area-->
    </div>

    <ul>
      <li class="fragment">Each new layer of tools adds latency from making a change to evaluation</li>
      <li class="fragment">Current generation of tools has ad-hoc support for <em>incremental compilation</em> of the design and simulator
      <ul>
        <li class="fragment"><strong class="green">Progress</strong>: LiveHD<span class="reference">[1]</span>, LiveSynth<span class="reference">[2]</span>, LiveSim<span class="reference">[3]</span>: efforts to make incremental execution and rapid iteration first-class features of the design cycle</li>
      </ul>
      </li>
    </ul>

    <div class="footnote fragment">
    [1] Coffman, Hunter, Kenneth Mayer, Sakshi Garg, and Jose Renau. "A Multi-threaded Fast Hardware Compiler for HDLs." CC’23.<br />
    [2] Possignolo, Rafael Trapani, and Jose Renau. "LiveSynth: Towards an interactive synthesis flow." DAC 2017.<br />
    [3] Skinner, Haven, Rafael Trapani Possignolo, Sheng-Hong Wang, and Jose Renau. "LiveSim: A fast hot reload simulator for HDLs." ISPASS 2020.
    </div>
    </div>
  </section>

  <section>
    <h2>1. <span class="red">Slow Iteration Cycle</span> - <span class="green">New Simulators</span></h2>
    <dl>
      <div class="fragment">
        <dt>Higher-abstraction simulators</dt>
        <dd><a href="https://docs.calyxir.org/debug/cider.html">Cider (Calyx)</a>, <a href="https://people.csail.mit.edu/bthom/asplos21-1.pdf">Cuttlesim (Koika)</a>, <a href="https://github.com/accellera-official/systemc">SystemC</a></dd>
      </div>

      <div class="fragment">
        <dt>RTL SW simulators</dt>
        <dd><a href="https://www.veripool.org/verilator/">Verilator</a>, <a href="https://github.com/circt/arc-tests">Arcilator</a>, <a href="https://yosyshq.readthedocs.io/projects/yosys/en/latest/cmd/write_cxxrtl.html">CXXRTL</a>, <a href="https://github.com/chipsalliance/treadle">Treadle</a>, <a href="https://github.com/ucsc-vama/essent">ESSENT</a>, <a href="https://github.com/ucsc-vama/essent/tree/repcut">RepCut</a>, <a href="https://github.com/pku-liang/ksim/tree/main">Khronos</a></dd>
      </div>

      <div class="fragment">
        <dt>HW accelerated RTL simulators</dt>
        <dd class="small"><strong><a href="https://fires.im/">FireSim</a></strong>, <a href="https://github.com/ManticoreRTL">Manticore</a> (FPGA) | <a href="https://github.com/dian-lun-lin/RTLflow">RTLFlow</a> (GPU) | <a href="https://dl.acm.org/doi/abs/10.1145/3613424.3614257">ASH</a> (ASIC) | <a href="https://arxiv.org/abs/2403.04714">Parendi</a> (Graphcore IPU)</dd>
      </div>
    </dl>

    <hr class="fragment">

    <ol>
      <li class="fragment">Higher-level abstractions {{ rightarrow }} lower startup latency and higher throughput</li>
      <li class="fragment">Optimize software RTL simulators {{ rightarrow }} higher throughput
        <ul class="small"><li>Memory layout, SIMD, multicore, step skipping, IR interpreters</li></ul>
      </li>
      <li class="fragment">Leverage specialized hardware {{ rightarrow }} faster evaluation of long workloads</li>
    </ol>

    <!--These simulators address iteration speed by either simulating higher level abstractions, optimizing simulation kernels, or using specialized hardware.-->
    <!--<p class="center fragment">Iteration speed is critical; simulation is the workhorse of HW design. SW RTL simulation isn't at its limit! HW accelerated RTL simulation has been scantly explored.</p>-->
  </section>

  <section>
    <div style="position:relative;">
    <h2>2. <span class="red">One Abstraction at a Time</a></h2>
    <img class="image no-margin" style="position:absolute; top: 0; right: 0; transform-origin: top right; transform: scale(1); padding: 0.3rem; width: 20%; z-index: 1;" src="./figs/latte24/current-paradigm.svg" />

    <div class="container" style="grid-template-columns: 1fr 1fr;">
      <div class="fragment"><img src="./figs/latte24/esp_flow.png" /></div>
      <div class="fragment">
    <pre><code class="scala" data-trim data-line-numbers>
class GCDMMIOBlackBox(val w: Int)
  extends BlackBox(Map("WIDTH" -> IntParam(w)))
  with HasBlackBoxResource
  with HasGCDIO
{
  addResource("/vsrc/GCDMMIOBlackBox.v")
}
    </code></pre>
      </div>
    </div>

    <ul>
      <li class="fragment">We are still far away from realizing true multi-abstraction interop
        <ul>
        <li class="fragment">Verilog blackboxing is too coarse-grained and means lowering everything to RTL</li>
        <li class="fragment">Designers can benefit from fine-grained interop</li>
        </ul>
      </li>
    </ul>

    <dl>
      <dt class="fragment">Elaboration time interop</dt><dd class="fragment">The practical mechanism (FFI) of invoking sub-generators<span class="reference">[1]</span></dd>
      <dt class="fragment">Runtime interop</dt><dd class="fragment">Runtime interaction semantics between abstractions</dd>
    </dl>

    <div class="footnote fragment">
      [1] Daly, Ross, Lenny Truong, and Pat Hanrahan. "Invoking and linking generators from multiple hardware languages using coreir." WOSET 2018.
    </div>

    </div>
  </section>

  <section>
    <h2 class="no-margin">2. <span class="green">New HDLs and Design Abstractions</span></h2>

    <dl class="smallish">
      <div class="fragment">
        <dt>Intermediate representations</dt>
        <dd class="small">
        <a href="https://github.com/chipsalliance/firrtl-spec">FIRRTL</a>,
        <a href="https://github.com/fabianschuiki/llhd">LLHD</a>,
        <a href="https://circt.llvm.org/docs/Dialects/">Circt</a> <small>(affine, handshake, ssp, pipeline, fsm, dc)</small>,
        <a href="https://dl.acm.org/doi/pdf/10.1145/3623278.3624767">HIR</a>,
        <a href="https://github.com/masc-ucsc/livehd/tree/master/lgraph">LGraph</a>/<a href="https://masc.soe.ucsc.edu/docs/woset19b.pdf">LNAST</a>,
        <a href="https://github.com/YosysHQ/yosys/blob/main/kernel/rtlil.h">Yosys RTLIL</a>,
        <a href="https://dl.acm.org/doi/abs/10.1145/3453483.3454075">Reticle</a>
        </dd>
      </div>
      <div class="fragment">
        <dt>RTL-level</dt>
        <dd class="small">
        <strong><a href="https://www.chisel-lang.org/">Chisel</a></strong>, <a href="https://github.com/SpinalHDL/SpinalHDL?tab=readme-ov-file">SpinalHDL</a> (Scala) |
        <a href="https://ieeexplore.ieee.org/document/1420905">Lava</a>, <a href="https://github.com/blarney-lang/blarney">Blarney</a> (Haskell) |
        <a href="https://github.com/amaranth-lang/amaranth">Amaranth</a>, <a href="https://www.myhdl.org/">MyHDL</a>, <a href="https://github.com/pymtl/pymtl3">PyMTL3</a>, <a href="https://github.com/UCSBarchlab/PyRTL">PyRTL</a>, <a href="https://github.com/phanrahan/magma">Magma</a>, (Python) |
        <a href="https://github.com/janestreet/hardcaml">HardCaml</a> (OCaml) |
        <a href="https://intel.github.io/rohd-website/">ROHD</a> (Dart) |
        <a href="https://github.com/masc-ucsc/pyrope_artifacts">pyrope</a>, <a href="https://github.com/veryl-lang/veryl">Veryl</a> (freestanding)
        </dd>
      </div>
      <div class="fragment">
        <dt>Dataflow</dt>
        <dd>
        <a href="https://spade-lang.org/">Spade</a>,
        <a href="https://github.com/kaist-cp/shakeflow">Shakeflow</a>,
        <a href="https://github.com/DFiantHDL/DFiant">DFiant</a>,
        <a href="https://github.com/JulianKemmerer/PipelineC">PipelineC</a>,
        <a href="https://www.redwoodeda.com/tl-verilog">TL-Verilog</a>
        </dd>
      </div>
      <div class="fragment">
        <dt>Control flow synthesis</dt>
        <dd>
        <a href="https://calyxir.org/">Calyx</a>,
        <a href="https://github.com/google/xls">XLS</a>,
        <a href="https://github.com/B-Lang-org/bsc">Bluespec</a>,
        <a href="https://github.com/mit-plv/koika">Koika</a>,
        <a href="https://clash-lang.org/">Clash</a>
        </dd>
      </div>
      <div class="fragment">
        <dt>Accelerator design languages</dt>
        <dd>
        <a href="https://spatial-lang.org/">Spatial</a>,
        <a href="https://capra.cs.cornell.edu/dahlia/">Dahlia</a>,
        <a href="https://dl.acm.org/doi/abs/10.1145/3352460.3358292">μIR</a>,
        <a href="https://github.com/cornell-zhang/heterocl">HeteroCL</a>,
        <a href="https://arxiv.org/pdf/2404.04815.pdf">Allo</a>
        </dd>
      </div>
      <div class="fragment">
        <dt>General HLS</dt>
        <dd>
        SystemC (<a href="https://eda.sw.siemens.com/en-US/ic/catapult-high-level-synthesis/">Catapult</a>),
        C++ (<a href="http://lightsail.legupcomputing.com/">LegUp</a>, <a href="https://github.com/Xilinx/HLS">Vitis HLS</a>)
        </dd>
      </div>
    </dl>

    <p class="center small fragment">Stack of Perl and macros in SystemVerilog <span class="green">{{ rightarrow }} new RTL-level DSLs</span></p>
    <p class="center fragment">Rich ecosystem of design languages enable higher productivity, <strong class="red">but are difficult to compose and integrate.</strong></p>
  </section>

  <section>
    <h2>2. <span class="green">New SoC Design Frameworks</span></h2>

    <ul class="fragment">
      <li><strong><a href="https://github.com/ucb-bar/chipyard">Chipyard</a></strong> (Berkeley)<!--: Chisel-based, cores (Rocket, BOOM, CVA6), accelerators (Gemmini, NVDLA), memory system + NoC--></li>
      <li><a href="https://www.esp.cs.columbia.edu/">ESP</a> (Columbia)<!--: Tile based SoC architecture, cores (CVA6, Ibex), accelerators (Verilog blackboxing), memory system + NoC--></li>
      <li><a href="http://parallel.princeton.edu/openpiton/">OpenPiton</a> (Princeton)<!--: Ariane + memory / uncore components--></li>
      <li><a href="https://github.com/pulp-platform/pulp">PULP</a> (ETH Zurich)<!--: Cores (RISCY, zero-riscy), ???--></li>
      <li><a href="https://github.com/black-parrot/black-parrot">BlackParrot</a> (UW)<!--: ???--></li>
      <li><a href="https://github.com/OpenXiangShan/XiangShan">Xiangshan</a> (Chinese Academy of Sciences)<!--: High performance OoO RISC-V core + L2--></li>
    </ul>

    <!--<div class="center fragment">
      <img class="image no-margin" src="./figs/dynamic/latte24/soc_construction.svg" />
      <p><em>Image of Makefile calling other Makefiles and being wrapped in yet another custom build system</em></p>
    </div>-->

    <!-- web of scripts and build systems, config systems on top of config systems -->

    <!--<ul>
      <li class="fragment">Composing IP correctly is hard. Satisfying global constraints, verifying every interface conforms, parameter propagation</li>
      <li class="fragment">SoC construction described in ad-hoc phases with yaml on top of Makefiles on top of Makefiles</li>
      <li class="fragment">Collateral emission at block and SoC level must understand the configuration of every IP</li>
    </ul>-->

    <p class="center fragment">Full system evaluation at <span class="green">RTL-level</span>.</p>
    <p class="center fragment"><span class="green">SoC level parameterization</span><span class="reference">[1]</span> and <span class="orange">integration of external IP</span>.</p>

    <div class="footnote fragment">
      [1] Cook, Henry, Wesley Terpstra, and Yunsup Lee. "Diplomatic design patterns: A TileLink case study." CARRV 2017.
    </div>
  </section>

  <section>
    <div style="position: relative;">
    <h2>3. <span class="red">Loss of Semantics</span></h2>
    <img class="image no-margin" style="position:absolute; top: 0; right: 0; transform-origin: top right; transform: scale(1); padding: 0.3rem; width: 20%; z-index: 1;" src="./figs/latte24/current-paradigm.svg" />

    <div class="container" style="grid-template-columns: 1fr 1fr; margin-bottom: 1rem;">
      <div>
        <img data-fragment-index=1 class="fragment image no-margin" src="./figs/dynamic/latte24/simulator_interop.svg" />
      </div>
      <div>
        <img data-fragment-index=3 style="z-index:9999;" class="fragment image no-margin" src="./figs/dynamic/latte24/synthesis_semantics.svg" />
      </div>
    </div>

    <ul>
      <li class="fragment" data-fragment-index=2>Lack of a common runtime interop model {{ rightarrow }} hacked together composition / slow iteration</li>
      <li class="fragment" data-fragment-index=4>Existing IRs erase design semantics {{ rightarrow }} must be recovered by synthesis / simulation tools, lower QoR</li>
    </ul>

    <!--<div class="center fragment">
      <img class="image no-margin" src="./figs/dynamic/latte24/typical_flow.svg" />
      <figcaption class="small">A pretty typical flow</figcaption>
      <p><em>Insert picture of ugly SystemVerilog macros, Perl generators</em></p>
    </div>-->

    <!--
    - ill defined / complex semantics, mixing simulation and synthesizable abstractions
    - multiple abstractions can only be blackboxed at the lowest level (practically)
    - massive monolithic simulation/emulation tools
    - macros on top of macros on top of web of Perl scripts
    -->

    <!--<ul class="small">
      <li class="fragment">Most design is done at the RTL abstraction in Verilog/VHDL</li>
      <li class="fragment">Limitations of these languages lead to a tower of macros on top of macros on top of a web of Perl</li>
      <li class="fragment">Simulation / synthesis semantics mismatch</li>
      <li class="fragment">Compositional semantics of mixing multiple abstractions isn't defined. Everything is lowered to RTL</li>
      <li class="fragment">Simulation / emulation tools are massive monolithic blobs</li>
    </ul>

    An adder is also a design semantic, we could have erased that and let synthesis recover it. but we don't. can we apply this elsewhere?-->
    </div>
  </section>

  <!--
    We're not going to mention the impact of the old / new paradigm on team organization (an industry concern that people here won't care about), or on beauty/ergonomics (too hard to explain in words).
    Also not going to talk about specification synthesis as part of the new paradigm (which includes machine readable specification). This is something we aren't experts on.
  -->

  <!--<section>
    <h2>People and Organization</h2>

    <table class="old_paradigm_table">
      <thead>
      <tr>
        <th></th>
        <th></th>
        <th colspan="5">Teams within an SoC Design Organization</th>
      </tr>
      <tr style="text-align: center;">
        <th></th>
        <th></th>
        <th>Spec / Arch</th>
        <th>Perf Modeling</th>
        <th>RTL</th>
        <th>DV</th>
        <th>PD</th>
      </tr>
      </thead>
      <tbody>
      <tr>
        <th rowspan="3" style="vertical-align: middle;">Design block</th>
        <th>Core</th>
        <td class="bg-red"></td>
        <td class="bg-orange"></td>
        <td></td>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <th>LLC</th>
        <td class="bg-red"></td>
        <td class="bg-orange"></td>
        <td></td>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <th>NPU</th>
        <td class="bg-red"></td>
        <td class="bg-orange"></td>
        <td></td>
        <td></td>
        <td></td>
      </tr>
      </tbody>
    </table>

    <ul>
      <li class="fragment">Highly specialized and large workforce</li>
      <li class="fragment">Teams are separated by function rather than design block</li>
      <li class="fragment">Duplicated work between specification, modeling, and RTL</li>
      <li class="fragment">Little interaction between teams</li>
      <li class="fragment">Complex tools and abstractions make transition between functions difficult</li>
    </ul>
  </section>-->

  <!--<section>
    <h2>Specification</h2>
    <div class="center fragment">
      <img class="image" src="./figs/dynamic/latte24/specification.svg" />
      <p><em>Insert picture of random excel spreadsheets, AXI spec documents, DDR state machines</em></p>
    </div>

    <ul>
      <li class="fragment">English, Excel, and drawing specs are the norm</li>
      <li class="fragment">Simulators, models, and verification collateral are handcrafted rather than generated</li>
      <li class="fragment">Translation errors due to undefined behaviors and misinterpretation are common</li>
    </ul>
  </section>-->

  <!--<section>
    <h2>Beauty / Elegance</h2>

    <ul>
      <li>Compare / contrast SystemC HLS vs Halide or EXO as an example</li>
      <li>How else can we demonstrate the lack of beauty?</li>
    </ul>
  </section>-->
</section>

<section>
  <section class="center">
    <h1>The Next Paradigm Shift of Hardware Design</h1>
  </section>

  <section>
    <h2>Flat Organization</h2>

    <table class="old_paradigm_table fragment custom new">
      <thead>
      <tr>
        <th></th>
        <th></th>
        <th colspan="5">Teams within an SoC Design Organization</th>
      </tr>
      <tr style="text-align: center;">
        <th></th>
        <th></th>
        <th>Spec / Arch</th>
        <th>Perf Modeling</th>
        <th>RTL</th>
        <th>DV</th>
        <th>PD</th>
      </tr>
      </thead>
      <tbody>
      <tr>
        <th rowspan="3" style="vertical-align: middle;">Design block</th>
        <th>Core</th>
        <td class="bg-red"></td>
        <td class="bg-orange"></td>
        <td></td>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <th>LLC</th>
        <td class="bg-red"></td>
        <td class="bg-orange"></td>
        <td></td>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <th>NPU</th>
        <td class="bg-red"></td>
        <td class="bg-orange"></td>
        <td></td>
        <td></td>
        <td></td>
      </tr>
      </tbody>
    </table>

    <ul>
      <li class="fragment">Agile, small, and generalist workforce</li>
      <li class="fragment">Teams are specialized by design block rather than function</li>
      <!--<li>Teams collaborate across functions</li>-->
      <li class="fragment">Design and specification artifacts are reused and contain semantics that span from specification to PD</li>
      <li class="fragment">Higher level abstractions enable productivity across the stack</li>
    </ul>
  </section>

  <section>
    <h2>Main Ideas</h2>
    <dl>
      <dt class="fragment">Frontends</dt>
      <dd class="fragment">Mixed-abstraction, interop semantics, ergonomic external module integration, embedding PD/power/verification collateral, rewrite/spec/compiler generation</dd>
      <dt class="fragment">IRs</dt>
      <dd class="fragment">Preservation of semantics, graph-oriented representation</dd>
      <dt class="fragment">Tools / Simulators</dt>
      <dd class="fragment">Low latency iteration cycle (incremental), full spectrum (from specification to PD)</dd>
    </dl>
  </section>

  <section>
    <h2>New Paradigm</h2>
    <img src="./figs/latte24/new-paradigm.svg" />
  </section>

</section>

<section>
  <section class="center">
    <h2>Berkeley's attempt<br>on the new HW design paradigm</h2>
    <ul>
      <li class="fragment">The RTL first methodology (just go write RTL)</li>
      <li class="fragment">Step towards higher design productivity</li>
      <li class="fragment">High fidelity evaluation results</li>
    </ul>
  </section>

  <section class="center">
    <h3>Typical hardware design cycle</h3>
    <div class="container" style="grid-template-columns: 1.0fr 1.4fr;">
      <div class="fragment">
        <img src="./figs/latte24/design-process.svg" />
      </div>
      <div>
        <font size="6">
        <ul>
          <li class="fragment">Iterate over a design point in various abstractions</li>
          <li class="fragment">You can get feedback from lower level abstractions</li>
          <li class="fragment">You are likely to run <strong>a lot of simulations</strong> in order to get functionality and performance correct</li>
        </ul>
        </font>
      </div>
    </div>
  </section>

  <section class="center">
    <h3>Problems of modeling</h3>
    <div class="container" style="grid-template-rows: 0.2fr 0.7fr;">
    <div>
      <img class="fragment" data-fragment-index="0" height=300px; src="./figs/latte24/modeling-errors.png" />
    </div>
    <div>
      <ul>
        <li class="fragment" data-fragment-index="0">Prone to errors</li>
        <li class="fragment">Redundant work</li>
      </ul>
    </div>
  </section>

  <section class="center">
    <h3>RTL first design methodology</h3>
    <div class="container" style="grid-template-columns: 1.0fr 1.4fr;">
      <div class="fragment">
        <img src="./figs/latte24/design-process-rtl-first.svg" />
      </div>
      <div>
        <font size="6">
        <ul>
          <li class="fragment">Modeling is required because <strong>RTL writing is hard</strong></li>
          <li class="fragment">Make RTL writing so easy that we can just do modeling with RTL</li>
          <li class="fragment">Model large systems with high evaluation fidelity!</li>
        </ul>
        </font>
      </div>
    </div>
  </section>

  <section class="center">
    <h3>Our efforts towards RTL first</h3>
    <ul>
      <li class="fragment">Design language : Chisel & FIRRTL</li>
      <li class="fragment">SoC evaluation framework : Chipyard & FireSim</li>
    </ul>
  </section>

  <section class="center">
    <h2>Chisel</h2>
    <ul>
      <li class="fragment">HDL embedded in Scala</li>
      <li class="fragment">Metaprogramming on top of the RTL abstraction</li>
      <ul>
        <li class="fragment">Scala enables high expressiveness compared to SV</li>
        <li class="fragment">Makes it much easier to read and write RTL</li>
      </ul>
    </ul>
  </section>

  <section data-auto-animate>
    <h3>Reduced Sum : System Verilog</h3>
    <pre data-id="code-animation"><code class="verilog" data-trim data-line-numbers>
    module MyModule
      #(parameter N, M)
      (
        input  [N-1:0] a [0:M-1],
        output [N-1:0] sum
      );
      ...

    endmodule
    </code></pre>
  </section>

  <section data-auto-animate>
    <h3>Reduced Sum : System Verilog</h3>
    <pre data-id="code-animation"><code class="verilog" data-trim data-line-numbers="8-18">
    module MyModule
      #(parameter N, M)
      (
        input  [N-1:0] a [0:M-1],
        output [N-1:0] sum
      );

      reg [N-1:0] tmp [0:M];

      tmp[0] = a[0];
      sum = tmp[M];

      genvar i;
      generate
        for (i = 1; i &lt; M; i = i + 1) begin
          tmp[i] = tmp[i-1] + a[i];
        end
      endgenerate
    endmodule
    </code></pre>
  </section>

  <section data-auto-animate>
    <h2>Reduced Sum : Chisel</h2>
    <pre data-id="code-animation"><code class="scala" data-trim data-line-numbers>
    class MyModule(N: Int, M: Int) extends Module {
      val io = IO(new Bundle {
        val a = Vec(M, Input(UInt(N.W)))
        val sum  = Output(UInt(N.W))
      })
      ...
    }
    </code></pre>
  </section>

  <section data-auto-animate>
    <h2>Reduced Sum : Chisel</h2>
    <pre data-id="code-animation"><code class="scala" data-trim data-line-numbers="6">
    class MyModule(N: Int, M: Int) extends Module {
      val io = IO(new Bundle {
        val a = Vec(M, Input(UInt(N.W)))
        val sum  = Output(UInt(N.W))
      })
      io.sum := io.a.reduce(_ + _)
    }
    </code></pre>
  </section>

  <section class="center">
    <h2>Chisel Implications</h2>
    <ul>
      <li class="fragment">Much less verbose when describing HW</li>
      <li class="fragment">Easier to compose modules programmatically</li>
      <li class="fragment">eDSL : enables us to use existing tools around the host language</li>
      <ul>
        <li class="fragment">Package manager</li>
        <li class="fragment">Build systems</li>
        <li class="fragment">LSP</li>
      </ul>
    </ul>
  </section>

  <section class="center">
    <h2>FIRRTL</h2>
    <ul>
      <li class="fragment">Intermediate representation for Chisel</li>
      <li class="fragment">Designed to represent the generated circuit after Chisel's elaboration (after all meta programming has executed)</li>
      <li class="fragment">SSA style in memory representation</li>
    </ul>
  </section>

  <section data-auto-animate>
    <h2>Reduced Sum : FIRRTL</h2>
    <pre data-id="code-animation"><code class="" data-trim data-line-numbers>
    circuit MyModule :
      module MyModule :
        ...
    </code></pre>
  </section>

  <section data-auto-animate>
    <h2>Reduced Sum : FIRRTL</h2>
    <pre data-id="code-animation"><code class="" data-trim data-line-numbers="2-5">
    circuit MyModule :
      module MyModule :
        input clock : Clock
        input reset : UInt&lbrack;1&rbrack;
        output io : { flip a : UInt&lbrack;4&rbrack;[4], sum : UInt&lbrack;4&rbrack;}

        node _io_sum_T = add(io.a[0], io.a[1]) @[MyModule.scala 14:27]
        node _io_sum_T_1 = tail(_io_sum_T, 1) @[MyModule.scala 14:27]
        node _io_sum_T_2 = add(_io_sum_T_1, io.a[2]) @[MyModule.scala 14:27]
        node _io_sum_T_3 = tail(_io_sum_T_2, 1) @[MyModule.scala 14:27]
        node _io_sum_T_4 = add(_io_sum_T_3, io.a[3]) @[MyModule.scala 14:27]
        node _io_sum_T_5 = tail(_io_sum_T_4, 1) @[MyModule.scala 14:27]
        io.sum &lt;= _io_sum_T_5 @[MyModule.scala 14:10]
    </code></pre>
    <p>FIRRTL resembles your circuit</p>
  </section>

  <section data-auto-animate>
    <h2>Reduced Sum : FIRRTL</h2>
    <pre data-id="code-animation"><code class="" data-trim data-line-numbers="7-13">
    circuit MyModule :
      module MyModule :
        input clock : Clock
        input reset : UInt&lbrack;1&rbrack;
        output io : { flip a : UInt&lbrack;4&rbrack;[4], sum : UInt&lbrack;4&rbrack;}

        node _io_sum_T = add(io.a[0], io.a[1]) @[MyModule.scala 14:27]
        node _io_sum_T_1 = tail(_io_sum_T, 1) @[MyModule.scala 14:27]
        node _io_sum_T_2 = add(_io_sum_T_1, io.a[2]) @[MyModule.scala 14:27]
        node _io_sum_T_3 = tail(_io_sum_T_2, 1) @[MyModule.scala 14:27]
        node _io_sum_T_4 = add(_io_sum_T_3, io.a[3]) @[MyModule.scala 14:27]
        node _io_sum_T_5 = tail(_io_sum_T_4, 1) @[MyModule.scala 14:27]
        io.sum &lt;= _io_sum_T_5 @[MyModule.scala 14:10]
    </code></pre>
    <p>Metaprogramming has executed</p>
  </section>

  <section data-auto-animate>
    <h3>Cool things that FIRRTL enables</h3>
    <ul>
      <li class="fragment">Netlist manipulation : scan-chains, reparenting modules (for PD)</li>
      <li class="fragment">Error checking, generic compiler optimizations</li>
      <ul>
        <li class="fragment">Combinational loop detection</li>
        <li class="fragment">DCE, CSE, Const Prop</li>
      </ul>
    </ul>
  </section>

  <section data-auto-animate>
    <h3>Cool things that FIRRTL enables</h3>
    <ul>
      <li class="fragment">FAME transformations and FireSim</li>
      <figure>
        <img class="fragment" src="./figs/latte24/li-bdn-transformed.svg" />
        <figcaption class="fragment">Bold lines : Target design<br>Dashed lines : Timing control logic</figcaption>
      </figure>
    </ul>
  </section>

  <section class="center">
    <h2>FIRRTL Implications</h2>
    <ul>
      <li class="fragment">Enables you to programmatically traverse/modify the netlist</li>
      <li class="fragment">Given a single design, you are now able to generate various collateral by applying different compiler passes</li>
    </ul>
  </section>

  <section class="center">
    <h2>What is Chipyard</h2>
    <div class="container" style="grid-template-columns: 1.4fr 1.0fr;">
    <div>
      <img src="./figs/latte24/soc-arch.svg"/>
    </div>
    <div>
      <font size="5">
      <ul>
        <li class="fragment">Generator based SoC design framework</li>
        <li class="fragment">Easy to configure a diverse set of SoC design space</li>
        <ul>
          <li class="fragment">IP shop for RISC-V cores, accelerators, memory elements and the bus hierarchy</li>
        </ul>
        <li class="fragment">Ensures correct composition of the modules during elaboration time</li>
        <ul>
          <li class="fragment">Parameter validity, SoC address space</li>
        </ul>
      </ul>
      </font>
    </div>
  </section>

  <section class="center">
    <h2>FireSim at 35,000 feet</h2>
    <div class="container" style="grid-template-columns: 1.0fr 1.4fr;">
    <div>
      <ul>
        <img class="fragment" data-fragment-index="0" height=400px; src="./figs/latte24/firesim.svg" />
      </ul>
    </div>
    <div>
      <font size="6">
      <ul>
        <li class="fragment" data-fragment-index="0">FPGA accelerated RTL simulation platform</li>
        <li class="fragment">Enables us to perform end-to-end performance evaluation of our designs by running entire RISC-V binaries</li>
        <li class="fragment">Useful for discovering bugs that appear trillions of cycles into simulation</li>
      </ul>
      </font>
    </div>
  </section>

{# <section class="center"> #}
{# <h2>Host decoupling</h2> #}
{# <div class="container" style="grid-template-columns: 1.2fr 1.0fr;"> #}
{# <div class="r-stack"> #}
{# <img class="fragment fade-in-then-out" data-fragment-index="0" src="./figs/latte24/firesim-before-transform.png"/> #}
{# <img class="fragment fade-in-then-out" data-fragment-index="1" src="./figs/latte24/firesim-after-transform.png"/> #}
{# <img class="fragment"                  data-fragment-index="2" src="./figs/latte24/firesim-mapped.png"/> #}
{# </div> #}
{# <div> #}
{# <font size="5"> #}
{# <ul> #}
{# <li class="fragment" data-fragment-index="0">Starting with your target</li> #}
{# <li class="fragment" data-fragment-index="1">Wrap the target RTL in a latency insensitive wrapper</li> #}
{# <li class="fragment" data-fragment-index="1">Attach a DRAM timing model using host FPGA resources</li> #}
{# <li class="fragment" data-fragment-index="1">These steps are automated by the FIRRTL compiler</li> #}
{# <li class="fragment" data-fragment-index="2">Map the simulation onto the host FPGA</li> #}
{# <li class="fragment" data-fragment-index="2">SoC now sees 100 cycles of DRAM latency!</li> #}
{# </ul> #}
{# </font> #}
{# </div> #}
{# </div> #}
{# </section> #}

  <section class="center">
    <h3>Overview of the Current Infrastructure</h3>
    <div class="container" style="grid-template-columns: 1.0fr 1.0fr;">
      <div class="fragment">
        <img src="./figs/latte24/tool-stack.svg" />
      </div>
      <div>
        <font size="6">
        <ul>
          <li class="fragment">Chisel & FIRRTL : Expressive frontend and flexible IR</li>
          <li class="fragment">Chipyard : Composable SoC generator framework</li>
          <li class="fragment">FireSim : Fast RTL simulation</li>
          <li class="fragment">Enabled countless research projects from both industry and academia for the last 5+ years</li>
        </ul>
        </font>
      </div>
    </div>
  </section>
</section>

{# ----------------------------------------------------------------------- #}

<section>
  <section class="center">
    <h3>Current methodology of mixed abstraction flow</h3>
    <ul>
    <li class="fragment">Demo : How to integrate your own IP to perform full system SoC level evaluation?</li>
    </ul>
  </section>

  <section class="center">
    <h3>Step 1 : Generate RTL from your HDL (e.g. Calyx)</h3>
    <pre data-id="code-animation"><code class="verilog" data-trim>
    component CalyxSumBlackBox(in: 4) -> (out: 4) {
      cells { ... }
      wires { ... }
      control { ... }
    }
    </code></pre>
    <ul>
      <li class="fragment">Given a input, add it three times to itself and output it</li>
    </ul>
  </section>

  <section class="center">
    <h3>Step 2 : Create a BlackBox Module in Chipyard</h3>
    <div class="container" style="grid-template-columns: 1.0fr 1.5fr;">
      <div>
        <pre data-id="code-animation"><code class="scala" data-trim data-line-numbers>
        class CalyxSumIO(nBits: Int) extends Bundle {
          val clk   = Input(Clock())
          val reset = Input(Bool())

          val in    = Input(UInt(nBits.W))
          val go    = Input(Bool())

          val out   = Output(UInt(nBits.W))
          val done  = Output(Bool())
        }

        class CalyxSumBlackBox(nBits: Int)
            extends BlackBox
            with HasBlackBoxResource {
          val io = IO(new CalyxSumIO(nBits))
          addResource("/vsrc/aggregator.sv")
        }
        </code></pre>
      </div>
      <div>
        <img class="fragment" src="./figs/latte24/calyx-verilog.svg"/>
      </div>
    <div>
  </section>

  <section data-auto-animate>
    <h3>Step 3 : Generate a MMIO wrapper in Chipyard</h3>
    <div class="container" style="grid-template-columns: 1.0fr 1.5fr;">
      <div>
        <font size="4">
        <pre data-id="code-animation"><code class="scala" data-trim data-line-numbers="1-35|37-73">
        case class CalyxSumParams(
          address: BigInt = 0x5000,
          qDepth: Int = 4,
          nBits: Int = 4,
          nSum: Int = 3)

        case object CalyxSumKey extends Field[Option[CalyxSumParams]](None)

        class CalyxSumMMIOWrapper(
          params: CalyxSumParams, beatBytes: Int
        )(
          implicit p: Parameters
        ) extends ClockSinkDomain(ClockSinkParameters())(p) {
          val device = new SimpleDevice("calyx-sum", Seq("ucbbar,calyx-sum"))
          val node = TLRegisterNode(Seq(AddressSet(params.address, 4096-1)),
                                        device,
                                        "reg/control",
                                        beatBytes=beatBytes)

          val nBits = params.nBits
          val nSum  = params.nSum

          override lazy val module = new MMIOWrapperImpl

          class MMIOWrapperImpl extends Impl with HasCalyxSumTopIO {
            val io = IO(new CalyxSumTopIO)

            withClockAndReset(clock, reset) {
              val bb    = Module(new CalyxSumBlackBox(nBits))
              val in_q  = Module(new Queue(UInt(nBits.W), params.qDepth))
              val out_q = Module(new Queue(UInt(nBits.W), params.qDepth))

              val go = RegInit(false.B)
              val cnt = RegInit(0.U(8.W))

              switch (go) {
                is (false.B) {
                  when (in_q.io.count > 0.U && out_q.io.enq.ready) {
                    go := true.B
                    cnt := 0.U
                  }
                }

                is (true.B) {
                  when (bb.io.done) {
                    go := false.B
                  }
                }
              }

              bb.io.clk   := clock
              bb.io.reset := reset.asBool
              bb.io.go    := go
              bb.io.in    := in_q.io.deq.bits
              in_q.io.deq.ready := bb.io.done

              out_q.io.enq.bits  := bb.io.out
              out_q.io.enq.valid := bb.io.done
              io.done := bb.io.done

              when (bb.io.done) {
                assert(out_q.io.enq.ready)
              }

              node.regmap(
                0x00 -> Seq(RegField.r(1,     in_q.io.enq.ready)),
                0x04 -> Seq(RegField.w(nBits, in_q.io.enq)),
                0x08 -> Seq(RegField.r(1,     out_q.io.deq.valid)),
                0x0C -> Seq(RegField.r(nBits, out_q.io.deq))
              )
            }
          }
        }
        </code></pre>
        </font>
      </div>
      <div>
        <img class="fragment" src="./figs/latte24/calyx-wrapped.svg"/>
      </div>
    </div>
  </section>

  <section data-auto-animate>
    <h3>Step 4 : Add MMIO ports to the bus</h3>
    <div class="container" style="grid-template-columns: 1.0fr 1.5fr;">
      <div>
        <font size="4">
          <pre data-id="code-animation"><code class="scala" data-trim data-line-numbers="">
          trait CanHaveMMIOCalyxSum { this: BaseSubsystem =>
            private val pbus = locateTLBusWrapper(PBUS)

            val calyx_sum_done = p(CalyxSumKey) match {
              case Some(params) => {
                val cs = LazyModule(new CalyxSumMMIOWrapper(params, pbus.beatBytes)(p))
                cs.clockNode := pbus.fixedClockNode
                pbus.coupleTo("calyx_sum_mmio_wrapper") {
                  cs.node := TLFragmenter(pbus.beatBytes, pbus.blockBytes) := _
                }

                // Add port to DigitalTop (just for fun)
                val calyx_sum_done = InModuleBody {
                  val done = IO(Output(Bool())).suggestName("calyx_sum_done")
                  done := cs.module.io.done
                  done
                }
                Some(calyx_sum_done)
              }
              case None => None
            }
          }

          // DOC include start: DigitalTop
          class DigitalTop(implicit p: Parameters) extends ChipyardSystem
            ...
            // Enables optionally adding a Calyx generated module as a MMIO device
            with chipyard.example.CanHaveMMIOCalyxSum
          {
            override lazy val module = new DigitalTopModule(this)
          }
          </code></pre>
        </font>
      </div>
      <div>
        <img class="fragment" src="./figs/latte24/demo-create-port.svg" />
      </div>
    </div>
  </section>

  <section data-auto-animate>
    <h3>Step 6 : Configure your SoC to use the MMIO module</h3>
    <div class="container" style="grid-template-columns: 1.0fr 1.5fr;">
      <div>
        <font size="5">
        <pre data-id="code-animation"><code class="scala" data-trim data-line-numbers>
        class WithCalyxSum extends Config((site, here, up) => {
          case CalyxSumKey => Some(CalyxSumParams())
        })

        class CalyxSumRocketConfig extends Config(
          new chipyard.example.WithCalyxSum ++
          new freechips.rocketchip.subsystem.WithNBigCores(1) ++
          new chipyard.config.AbstractConfig)
        </code></pre>
        </font>
      </div>
      <div>
        <img class="fragment" src="./figs/latte24/demo-overall-soc.svg" />
      </div>
    </div>
    <p>At this point, the SoC level configuration is finished</p>
  </section>

  <section data-auto-animate>
    <h3>Step 7 : Write software to talk to the MMIO device</h3>
    <font size="4">
    <pre data-id="code-animation"><code class="cpp" data-trim data-line-numbers="1-36|21-57">
    ...

    #define CALYX_SUM_BASE 0x5000
    #define CALYX_SUM_ENQ_RDY  (CALYX_SUM_BASE + 0)
    #define CALYX_SUM_ENQ_BITS (CALYX_SUM_BASE + 4)
    #define CALYX_SUM_DEQ_VAL  (CALYX_SUM_BASE + 8)
    #define CALYX_SUM_DEQ_BITS (CALYX_SUM_BASE + 12)


    static inline int calyx_sum_enq_ready() {
      int rdy = reg_read32(CALYX_SUM_ENQ_RDY);
      printf("calyx_sum_enq_ready: %d\n", rdy);
      return (rdy != 0);
    }

    static inline void calyx_sum_send_input(int val) {
      while (!calyx_sum_enq_ready());
      printf("sending input: %d\n", val);
      reg_write32(CALYX_SUM_ENQ_BITS, val & 0xf);
      printf("sending input done\n");
    }

    static inline int calyx_sum_deq_valid() {
      int val = reg_read32(CALYX_SUM_DEQ_VAL);
      printf("calyx_sum_deq_val: %d\n", val);
      return (val != 0);
    }

    static inline int calyx_sum_get_output() {
      while (!calyx_sum_deq_valid());
      return reg_read32(CALYX_SUM_DEQ_BITS);
    }

    ...

    #define TEST_SIZE 3

    int main() {

      int test_inputs[TEST_SIZE] = {1, 2, 3};

      for (int i = 0; i &lt; TEST_SIZE; i++) {
        calyx_sum_send_input(test_inputs[i]);

        int out = calyx_sum_get_output();
        int expect = test_inputs[i] * 3;

        if (out != expect) {
          printf("expect %d got %d\n", expect, out);
          return 1;
        }
      }
      printf("[*] Test success!\n");
      return 0;
    }
    </code></pre>
    </font>
  </section>

  <section data-auto-animate>
    <h3>Step 8 : Run SoC level integration tests</h3>
    <pre data-id="code-animation"><code class="bash" data-trim data-line-numbers="5">
    cd chipyard/tests
    make
    cd -
    cd chipyard/sims/verilator
    make -j$(nproc) run-binary CONFIG=CalyxSumRocketConfig BINARY=../../tests/calyx-sum.riscv
    </code></pre>
  </section>

  <section class="center">
    <h3>Step 8 : Run SoC level integration tests</h3>
    <img height=500px; src="./figs/latte24/calyx-uartlog.png" />
  </section>

  <section class="center">
    <h2>Resources</h2>
    <div class="container" style="grid-template-columns: 1.0fr 1.0fr;">
      <div>
        <img src="./figs/latte24/chipyard-docs.svg"/>
        <img src="./figs/latte24/firesim-docs.jpg"/>
      </div>
      <div>
        <ul>
          <li><a href="https://chipyard.readthedocs.io/en/stable/">Chipyard docs</a></li>
          <li><a href="https://docs.fires.im/en/stable/">FireSim docs</a></li>
          <li><a href="https://fires.im/asplos-2023-tutorial/">Link to previous tutorial recordings</a></li>
        </ul>
      </div>
    </div>
  </section>
</section>

<!-- -------------------------------------------------------------------- -->


<section>
  <section class="center">
    <h2>Why have we not reached the next paradigm?</h2>
  </section>

  <section class="center">
    <h3>Why have we not reached the next paradigm?</h3>
    <div class="container" style="grid-template-columns: 1.4fr 1.0fr;">
      <div>
        <img src="./figs/latte24/current-paradigm.svg"/>
      </div>
      <div>
        <ul>
          <ol class="fragment">1. Long iteration time</ol>
          <ol class="fragment">2. Lost design productivity</ol>
          <ol class="fragment">3. Lost semantics</ol>
        </ul>
      </div>
    </div>
  </section>

{# <section class="center"> #}
{# <h3>Why have we not reached the next paradigm?</h3> #}
{# <ul> #}
{# <li class="fragment">Iteration cycle</li> #}
{# <ul> #}
{# <li class="fragment">Compile/simulation time</li> #}
{# <li class="fragment">Fast power/area estimation capabilities</li> #}
{# </ul> #}
{# <li class="fragment">Utilizing the suitable abstractions</li> #}
{# <ul> #}
{# <li class="fragment">Design productivity</li> #}
{# <li class="fragment">IP integration is always at the RTL level</li> #}
{# <ul> #}
{# <li class="fragment">Ad-hoc blackboxing or DPI interfaces</li> #}
{# <li class="fragment">Compromising simulation throughput</li> #}
{# </ul> #}
{# </ul> #}
{# <li class="fragment">Other concerns</li> #}
{# <ul> #}
{# <li class="fragment">Physical design, verification</li> #}
{# specifying clock/reset/power domains should be more explicit (we need to encode upf files in the frontend language) #}
{# Since we are not specifying these semantics, we can't simulate these things. #}
{# <li class="fragment">Missing power/clock/reset semantics</li> #}
{# <li class="fragment">Need a systematic way of generating collateral from specs</li> #}
{# </ul> #}
{# </ul> #}
{# </section> #}

{# <section class="center"> #}
{# <h3>Feature Requests</h3> #}
{# <div class="container" style="grid-template-columns: 1.0fr 1.4fr;"> #}
{# <div> #}
{# <img src="./figs/latte24/feature-request.jpg" /> #}
{# </div> #}
{# <div> #}
{# <font size="6"> #}
{# <ul> #}
{# <li class="fragment">Fast compilation time as well as quick feedback from the backend tools</li> #}
{# <li class="fragment">Fast simulation that doesn't require hours of compile time</li> #}
{# <li class="fragment">Support for higher level abstractions to enable designers to work on various levels of abstractions</li> #}
{# </ul> #}
{# </font> #}
{# </div> #}
{# </div> #}
{# </section> #}

  <section class="center">
    <h3>Rest of the talk</h3>
    <div class="container" style="grid-template-columns: 1.0fr 1.4fr;">
    <div>
      <img src="./figs/latte24/tool-stack.svg" />
    </div>
    <div>
      <ul>
        <li class="fragment">Our vision for rethinking the end-to-end flow for chip design</li>
      </ul>
    </div>
    </div>
  </section>
</section>

<!-- -------------------------------------------------------------------- -->

<section>
  <section class="center">
    <h2>Language Frontend & IR</h2>
  </section>

  <section class="center">
    <h3>Language Frontend & IR</h3>
    <div class="container" style="grid-template-columns: 1.4fr 1.0fr;">
      <div>
        <img src="./figs/latte24/new-paradigm.svg"/>
      </div>
      <div>
        <font size="5">
        <ul>
          <ol class="fragment">1. Incremental compilation and cacheing</ol>
          <ol class="fragment">2. Mixed abstraction by elaboration interop</ol>
          <ol class="fragment">3. Runtime interop + IR primitives for semantics preservation</ol>
        </ul>
        </font>
      </div>
    </div>
  </section>

{# <section class="center"> #}
{# <h2>Chipyard Compile Steps</h2> #}
{# <ul> #}
{# <li class="fragment">Scala FIRRTL Compiler (SFC) : Compiles the scala sources and generates CHIRRTL</li> #}
{# <li class="fragment">MLIR FIRRTL Compiler (MFC) : Emits Verilog from CHIRRTL</li> #}
{# <li class="fragment">Verilator : Verilog to C++ binary</li> #}
{# </ul> #}
{# </section> #}

{# <section class="center"> #}
{# <h2>Chipyard Compile Steps</h2> #}
{# <div class="container" style="grid-template-rows: 0.1fr 0.7fr;"> #}
{# <div> #}
{# <img src="./figs/latte24/compile-time.svg" /> #}
{# </div> #}
{# </div> #}
{# </section> #}

  <section data-auto-animate>
    <h2>Incremental First</h2>
    <ul>
      <li class="fragment">Hardware designers want more iterations to perform experiments</li>
      <li class="fragment">Most of the times, we write the entire module, and make small fixes to the control logic</li>
    </ul>
    <pre data-id="code-animation"><code class="scala" data-trim data-line-numbers="6">
    class MyModule(N: Int, M: Int) extends Module {
      val io = IO(new Bundle {
        val a = Vec(M, Input(UInt(N.W)))
        val sum  = Output(UInt((N + M - 1).W))
      })
      io.sum := io.a.reduce(_ + _)
    }
    </code></pre>
  </section>

  <section data-auto-animate>
    <h2>Incremental First</h2>
    <pre data-id="code-animation"><code class="scala" data-trim data-line-numbers="6">
    class MyModule(N: Int, M: Int) extends Module {
      val io = IO(new Bundle {
        val a = Vec(M, Input(UInt(N.W)))
        val sum  = Output(UInt((N + M - 1).W))
      })
      io.sum := io.a.reduce(_ +& _)
    }
    </code></pre>
    <p class="fragment">Code compilation time becomes the bottleneck</p>
  </section>

  <section class="center">
    <h2>Incremental First</h2>
    <ul>
      <li class="fragment">This problem can be solved by adopting the incremental first approach to hardware design</li>
      <li class="fragment"><strong>Partial compilation & Cacheing</strong></li>
    </ul>
  </section>

  <section class="center">
    <h2>Incremental First</h2>
    <div class="container" style="grid-template-columns: 1.4fr 1.0fr;">
      <div class="r-stack">
        <img class="fragment fade-in-then-out" data-fragment-index="0" src="./figs/latte24/incremental-1.svg" />
        <img class="fragment fade-in-then-out" data-fragment-index="1" src="./figs/latte24/incremental-2.svg" />
        <img class="fragment fade-in-then-out" data-fragment-index="2" src="./figs/latte24/incremental-3.svg" />
        <img class="fragment fade-in-then-out" data-fragment-index="3" src="./figs/latte24/incremental-4.svg" />
        <img class="fragment fade-in-then-out" data-fragment-index="4" src="./figs/latte24/incremental-5.svg" />
      </div>
      <div>
        <ul>
          <li class="fragment" data-fragment-index="1">classfiles are cached by the build system of the host language</li>
          <li class="fragment" data-fragment-index="2">Builder has to manage the cache for the generated output (*.sv)</li>
          <li class="fragment" data-fragment-index="3">A1.class is invalidated by the host language build system</li>
          <li class="fragment" data-fragment-index="4">Builder.class investigates A1.class to see if there are any changes made</li>
        </ul>
      </div>
    </div>
  </section>

  <section class="center">
    <h2>Incremental First</h2>
    <ul>
      <li class="fragment">We get halfway there just by utilizing the host buildsystem</li>
      <li class="fragment">Should be supported by all levels of the stack</li>
      <ul>
        <li class="fragment">Only small changes are propagated</li>
      </ul>
    </ul>
  </section>

  <section class="center">
    <h2>Mixed Abstractions</h2>
    <ul>
      <li class="fragment">We want to raise the level of abstraction to make HW design easier</li>
      <ul>
        <li class="fragment">Accelerators, initial prototyping stage, (possibly) the bus hierarchy</li>
      </ul>
      <li class="fragment">However, we also need lower level abstractions (RTL) when designing an SoC</li>
      <ul>
        <li class="fragment">High perf cores and caches</li>
      </ul>
    </ul>
  </section>

  <section class="center">
    <h2>Mixed Abstractions</h2>
    <div class="container" style="grid-template-columns: 1.4fr 1.0fr;">
    <div>
        <img src="./figs/latte24/new-paradigm-elab-interop.svg"/>
    </div>
    <div>
      <ul>
        <li class="fragment">Clean elaboration interop</li>
        <li class="fragment">Different abstractions sits on top</li>
      </ul>
    </div>
  </section>

  <section data-auto-animate>
    <h2>Mixed Abstraction</h2>
    <div class="container" style="grid-template-columns: 1.4fr 1.0fr;">
    <div>
      <pre data-id="code-animation"><code class="scala" data-trim data-line-numbers>
      object ElaborationInterop {
        def compose(rtl : RTL, hls: HLS): Option[Edge]
        def compose(rtl : RTL, als: ALS): Option[Edge]
      }
      </code></pre>
      <img class="fragment" src="./figs/latte24/elab-interop.svg" />
    </div>
    <div>
      <ul>
        <li class="fragment">Composes different abstractions together</li>
        <li class="fragment">Checks if the compositions are valid</li>
      </ul>
    </div>
  </section>

  <section class="center">
    <h2>Semantics Preserving</h2>
    <ul>
      <li class="fragment">Abstraction level semantics</li>
      <ul>
        <li class="fragment">How time advances during simulation?</li>
      </ul>
      <li class="fragment">Circuit level semantics</li>
      <ul>
        <li class="fragment">Which circuit primitives should we use?</li>
      </ul>
      <li class="fragment">Both broken when lowering to RTL</li>
    </ul>
  </section>

  <section class="center">
    <h2>Semantics Preserving</h2>
    <div class="container" style="grid-template-columns: 1.4fr 1.0fr;">
    <div class="r-stack">
      <img class="fragment" src="./figs/latte24/new-paradigm-runtime-interop.svg" />
    </div>
    <div>
      <ul>
        <li class="fragment">Runtime interop : abstraction level semantics</li>
      </ul>
    </div>
  </section>

  <section class="center">
    <h2>Semantics Preserving</h2>
    <div class="container" style="grid-template-columns: 1.4fr 1.0fr;">
      <div class="r-stack">
        <img class="fragment fade-in-then-out" data-fragment-index="0" src="./figs/latte24/runtime-interop-1.svg" />
        <img class="fragment fade-in-then-out" data-fragment-index="1" src="./figs/latte24/runtime-interop-2.svg" />
        <img class="fragment fade-in-then-out" data-fragment-index="2" src="./figs/latte24/runtime-interop-3.svg" />
        <img class="fragment"                  data-fragment-index="3" src="./figs/latte24/runtime-interop-4.svg" />
      </div>
      <div>
        <font size="5">
        <ul>
          <li class="fragment" data-fragment-index="0">RT interop : dictates how time advances between each abstraction boundary</li>
          <li class="fragment" data-fragment-index="0">Send req (function call)</li>
          <li class="fragment" data-fragment-index="1">RTL advances time</li>
          <li class="fragment" data-fragment-index="3">Runtime interop schedules the response & updates timing</li>
        </ul>
        </font>
      </div>
    </div>
    <ul>
      <li class="fragment">Faster simulation throughput than naive cycle-by-cycle updates</li>
      <li class="fragment">Must consider various interface boundaries (e.g. lat-insensitive, wires, function calls, ...)</li>
    </ul>
  </section>

  <section class="center">
    <h2>Semantics Preserving</h2>
    <div class="container" style="grid-template-columns: 1.4fr 1.0fr;">
    <div class="r-stack">
      <img class="fragment" src="./figs/latte24/new-paradigm-common-ir.svg" />
    </div>
    <div>
      <ul>
        <li class="fragment">Common IR : circuit level semantics</li>
      </ul>
    </div>
  </section>

  <section class="center">
    <h2>Semantics Preserving</h2>
    <div class="container" style="grid-template-columns: 1.0fr 1.0fr;">
    <div>
      <pre data-id="code-animation"><code class="verilog" data-trim data-line-numbers>
      input [3:0] uint_val,
      input [3:0] one_hot,
      </code></pre>
    </div>
    <div>
      <ul>
        <li class="fragment">SV : no notion of circuit semantics</li>
        <li class="fragment">Semantics recreated : time consuming & low QoR</li>
      </ul>
    </div>
  </section>

  <section class="center">
    <h2>Semantics Preserving</h2>
    <div class="container" style="grid-template-columns: 1.0fr 1.0fr;">
    <div>
      <pre data-id="code-animation"><code class="verilog" data-trim data-line-numbers>
      case class Clock(...)
      case class Reset(...)
      case class PriorityMux(...)
      case class UInt(...)
      case class OH(...)
      case class BitVector(...)
      </code></pre>
    </div>
    <div>
      <font size="5">
      <ul>
        <li class="fragment">Pass logical semantics from upper levels</li>
        <li class="fragment">Backend tools directly operate on the IR (instead of verilog)</li>
        <li class="fragment">Logical representation can be casted into different physical representations</li>
        <ul>
          <li class="fragment">FSM states can be UInt or BitVector depending on the number of states</li>
        </ul>
      </ul>
      </font>
    </div>
  </section>

  <section class="center">
    <h3>RTL Level IR : Better In Memory Representation</h3>
    <ul>
      <li class="fragment">Why does this even matter?</li>
      <li class="fragment">The primitives available in your IR affects QoR</li>
    </ul>
  </section>

  <section data-auto-animate>
    <h3>SSA Rep. Problem</h3>
    <p>FIRRTL's combinational loop detection pass</p>
    <pre data-id="code-animation"><code class="scala" data-trim data-line-numbers="1-6|23,27,31|8,13,14,15,18,19|42">
    class CheckCombLoops
        extends Transform
        with RegisteredTransform
        with DependencyAPIMigration {

      ...

      private def getStmtDeps(
        simplifiedModules: mutable.Map[String, AbstractConnMap],
        deps:              MutableConnMap
      )(s:                 Statement
      ): Unit = s match {
        case Connect(info, loc, expr) => ...
        case w: DefWire => ...
        case DefNode(info, name, value) =>
          ...
          getExprDeps(deps, lhs, info)(value)
        case m: DefMemory if (m.readLatency == 0) => ...
        case i: WDefInstance => ...
        case _ => s.foreach(getStmtDeps(simplifiedModules, deps))
      }

      private def run(state: CircuitState) = {
        ...
        topoSortedModules.foreach {
          ...
          case m: Module =>
            val portSet = m.ports.map(p => LogicNode(p.name)).toSet
            val internalDeps = new MutableDiGraph[LogicNode] with MutableEdgeData[LogicNode, Info]
            portSet.foreach(internalDeps.addVertex(_))
            m.foreach(getStmtDeps(simplifiedModuleGraphs, internalDeps))

            moduleGraphs(m.name) = internalDeps
            simplifiedModuleGraphs(m.name) = moduleGraphs(m.name).simplify(portSet)
            // Find combinational nodes with self-edges; this is *NOT* the same as length-1 SCCs!
            for (unitLoopNode &lt;- internalDeps.getVertices.filter(v =&gt; internalDeps.getEdges(v).contains(v))) {
              errors.append(new CombLoopException(m.info, m.name, Seq(unitLoopNode.name)))
            }

            for (scc &lt;- internalDeps.findSCCs.filter(_.length &gt; 1)) {
              val sccSubgraph = internalDeps.subgraph(scc.toSet)
              val cycle = findCycleInSCC(sccSubgraph)
              (cycle.zip(cycle.tail)).foreach({ case (a, b) =&gt; require(internalDeps.getEdges(a).contains(b)) })
              // Reverse to make sure LHS comes after RHS, print repeated vertex at start for legibility
              val intuitiveCycle = cycle.reverse
              val repeatedInitial = prettyPrintAbsoluteRef(Seq(m.name), intuitiveCycle.head)
              val expandedCycle = expandInstancePaths(m.name, moduleGraphs, moduleDeps, Seq(m.name), intuitiveCycle)
              errors.append(new CombLoopException(m.info, m.name, repeatedInitial +: expandedCycle))
            }
          case m => throwInternalError(s"Module ${m.name} has unrecognized type")
        }
        ...
      }
    }
    </code></pre>
    <div class="r-stack">
      <p id="special1" style="transition: all .2s ease; opacity: 0; visibility: hidden; will-change: opacity;">We are traversing the statements to build a graph of the nodes</p>
      <p id="special2" style="transition: all .2s ease; opacity: 0; visibility: hidden; will-change: opacity;">We are traversing the graph once again to check for comb loops</p>
    </div>
  </section>

  <section class="center">
    <h3>Graph Rep</h3>
    <ul>
      <li class="fragment">The above pattern of traversing the graph twice is a very common pattern in FIRRTL passes</li>
      <li class="fragment">If we had a graph representation of the circuit, we wouldn't have had to traverse the circuit twice</li>
      <li class="fragment">Compared to a SSA style, "human readable" IR, debugging passes might become more difficult</li>
    </ul>
  </section>

{# <section class="center"> #}
{# <h3>Existing Abstractions</h3> #}
{# <ul> #}
{# <li class="fragment">Gate level : lets ignore this for now..</li> #}
{# <li class="fragment">RTL : Explicitly defining registers and wires (e.g., Verilog, S-Verilog, Chisel)</li> #}
{# <li class="fragment">Calyx : Explicit HW instantiations, imperative control flow</li> #}
{# <li class="fragment">HLS : High level descriptions, compiler does it all</li> #}
{# </ul> #}
{# </section> #}

{# <section class="center"> #}
{# <h2>Problems with Mixing</h2> #}
{# <div class="container" style="grid-template-columns: 1.0fr 1.4fr;"> #}
{# <div> #}
{# <img src="./figs/latte24/oil-water.jpg" /> #}
{# </div> #}
{# <div> #}
{# <font size="6"> #}
{# <ul> #}
{# <li class="fragment">Clean (and good looking) APIs between the abstractions</li> #}
{# <li class="fragment">Compiler backend that can stitch different abstractions together</li> #}
{# </ul> #}
{# </font> #}
{# </div> #}
{# </div> #}
{# </section> #}

{# <section class="center"> #}
{# <h2>Clean API</h2> #}
{# <ul> #}
{# <li class="fragment">Mixing abstractions in the module granularity seems reasonable</li> #}
{# <ul> #}
{# <li class="fragment">Clean separation of compilers between abstractions</li> #}
{# <li class="fragment">IO ports are concrete targets that the HLS compilers can try abstracting away</li> #}
{# </ul> #}
{# </section> #}

{# <section class="center"> #}
{# <h4>How should the HLS APIs look like in this world?</h4> #}
{# <ul> #}
{# <li class="fragment">Want to separate the compute description from the compiler flags (HeteroCL)</li> #}
{# <li class="fragment">Want to specify the HLS compiler flags in a single location</li> #}
{# <ul> #}
{# <li class="fragment">Easier to specify relationships between flags</li> #}
{# <li class="fragment">Cleaner code</li> #}
{# </ul> #}
{# <li class="fragment">Want to abstract out the bus/RTL interface</li> #}
{# <li class="fragment">Want to pass parameters from the SoC side</li> #}
{# </ul> #}
{# </section> #}

{# <section class="center"> #}
{# <h2>Compiler Backend - Goals</h2> #}
{# <div class="container" style="grid-template-columns: 1.4fr 1.0fr;"> #}
{# <div> #}
{# <img src="./figs/latte24/backend-questionmark.svg" style="height: 500px;"/> #}
{# </div> #}
{# <div> #}
{# <font size="6"> #}
{# <ul> #}
{# <li class="fragment">High simulation performance (don't lower everying into RTL)</li> #}
{# <li class="fragment">High QoR (need to preserve circuit semantics)</li> #}
{# </ul> #}
{# </font> #}
{# </div> #}
{# </div> #}
{# </section> #}

{# <section class="center"> #}
{# <h2>Compiler Backend - RTL Simulation</h2> #}
{# <div class="container" style="grid-template-columns: 1.4fr 1.0fr;"> #}
{# <div> #}
{# <img src="./figs/latte24/backend-rtl-sim.png" style="height: 500px;"/> #}
{# </div> #}
{# <div> #}
{# <font size="6"> #}
{# <ul> #}
{# <li class="fragment">Instead of lowering higher level abstractions into RTL, emit discrete event models and link them during simulator compile time</li> #}
{# </ul> #}
{# </font> #}
{# </div> #}
{# </div> #}
{# </section> #}

{# <section class="center"> #}
{# <h2>Compiler Backend - RTL Simulation</h2> #}
{# <div class="container" style="grid-template-columns: 1.4fr 1.0fr;"> #}
{# <div> #}
{# <img src="./figs/latte24/backend-rtl-sim-details.png" style="height: 500px;"/> #}
{# </div> #}
{# <div> #}
{# <font size="6"> #}
{# <ul> #}
{# <li class="fragment">Need to define a common transaction scheme between various abstractions</li> #}
{# <li class="fragment">The scheduler can make optimizations across all abstractions</li> #}
{# </ul> #}
{# </font> #}
{# </div> #}
{# </div> #}
{# </section> #}

{# <section class="center"> #}
{# <h2>Compiler Backend - FPGA / ASIC</h2> #}
{# <div class="container" style="grid-template-columns: 1.4fr 1.0fr;"> #}
{# <div> #}
{# <img src="./figs/latte24/backend-fpga-asic.svg" style="height: 500px;"/> #}
{# </div> #}
{# <div> #}
{# <font size="6"> #}
{# <ul> #}
{# <li class="fragment">IRs such as Calyx & "RTL IR" should be able to preserve circuit semantics</li> #}
{# <li class="fragment">In the short term we can generate Verilog</li> #}
{# <li class="fragment">In the long term, fix backend tools to directly operate on the "RTL IR"</li> #}
{# </ul> #}
{# </font> #}
{# </div> #}
{# </div> #}
{# </section> #}

{# <section class="center"> #}
{# <h2>Compiler Backend - Overall</h2> #}
{# <img src="./figs/latte24/backend-all.png" style="height: 500px;"/> #}
{# </section> #}
</section>

<!-- -------------------------------------------------------------------- -->

{# <section> #}
{# <section class="center"> #}
{# <h2>Intermediate Representation (IR)</h2> #}
{# </section> #}

{# <section class="center"> #}
{# <h3>RTL Level IR : Better In Memory Representation</h3> #}
{# <div class="container" style="grid-template-columns: 1.4fr 1.0fr;"> #}
{# <div> #}
{# <img src="./figs/latte24/rtl-ir.png" style="height: 500px;" class="fragment"/> #}
{# </div> #}
{# <div> #}
{# <font size="5"> #}
{# <ul> #}
{# <li class="fragment">Why does this even matter?</li> #}
{# <li class="fragment">The primitives available in your IR affects QoR</li> #}
{# <li class="fragment">The in memory representation of the circuit affects compiler performance</li> #}
{# </ul> #}
{# </font> #}
{# </div> #}
{# </div> #}
{# </section> #}


{# <section class="center"> #}
{# <h4>FIRRTL In Memory Representation Problem 2</h4> #}
{# <pre data-id="code-animation"><code class="scala" data-trim data-line-numbers> #}
{# case class Mux(...) #}
{# case class UIntLiteral(...) #}
{# case class SIntLiteral(...) #}
{# case class DefWire(...) #}
{# case class DefRegister(...) #}
{# case class DefInstance(...) #}
{# case class DefMemory(...) #}
{# abstract class PrimOp extends FirrtlNode #}
{# </code></pre> #}
{# <ul> #}
{# <li class="fragment">Limited set of primitives &rarr; QoR may be low</li> #}
{# <li class="fragment">Compiler & backend tools spends a lot of time recreating semantics</li> #}
{# </ul> #}
{# </section> #}

{# <section class="center"> #}
{# <h4>Possible Primitives</h4> #}
{# <pre data-id="code-animation"><code class="scala" data-trim data-line-numbers="9-14"> #}
{# case class Mux(...) #}
{# case class UIntLiteral(...) #}
{# case class SIntLiteral(...) #}
{# case class DefWire(...) #}
{# case class DefRegister(...) #}
{# case class DefInstance(...) #}
{# case class DefMemory(...) #}
{# abstract class PrimOp extends FirrtlNode #}
{# case class Clock(...) #}
{# case class Reset(...) #}
{# case class OH(...) #}
{# case class PriorityMux(...) #}
{# case class BoolLiteral(...) #}
{# case class DecoupledInterface(...) #}
{# </code></pre> #}
{# <ul> #}
{# <li class="fragment">Add more primitives such that we can preserve more higher level circuit semantics</li> #}
{# <li class="fragment">Need to find a good balance between pass writing vs QoR</li> #}
{# </ul> #}
{# </section> #}

{# <section class="center"> #}
{# <h3>Support for Multiple Abstractions</h3> #}
{# <div class="container" style="grid-template-columns: 1.5fr 1.0fr;"> #}
{# <div class="fragment"> #}
{# <img src="./figs/latte24/backend-all.png" style="height: 500px;"/> #}
{# </div> #}
{# <div> #}
{# <font size="5"> #}
{# <ul> #}
{# <li class="fragment">As we discussed, the IRs have to be able to support multiple abstractions from the frontend</li> #}
{# </ul> #}
{# </font> #}
{# </div> #}
{# </div> #}
{# </section> #}
{# </section> #}

<!-- -------------------------------------------------------------------- -->

<section>
  <section class="center">
    <h2>Conclusion</h2>
  </section>
</section>

<section>
  <section class="center">
    <h2>Reference</h2>
  </section>
</section>

{% endblock %}
