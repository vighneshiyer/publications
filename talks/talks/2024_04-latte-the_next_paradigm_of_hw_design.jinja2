{% extends "base/base.jinja2" %}

{# HTML title #}
{% set webpage_title = "Chisel/Chipyard Demo + The Next Paradigm of SoC Design" %}
{# Short description #}
{% set description = "" %}
{# List of authors #}
{% set author = "Joonho Whangbo, Vighnesh Iyer" %}
{# Change ‘venue’ to a conference or workshop name if any #}
{% set venue = "LATTE 2024" %}
{# Publication info (hidden by default) #}
{% set pub_datetime_iso = "2024-04-29" %}
{% set pub_date = "April 29, 2024" %}

{# Custom styles and JS for a particular talk #}
{% block custom_head %}
<style>
.reveal table.old_paradigm_table {
  width: 100%;
  font-size: 60%;
  border-collapse: separate;
  border-spacing: 0.1rem;
  margin-bottom: 1rem;
  tr > th {
    text-align:center;
    border: none;
  }
  tr > td {
      border: 2px solid black !important;
      border-radius: 5px;
  }
  tbody tr td {
      width: 16.6666%;
      height: 1rem;
      text-align: center;
      vertical-align: middle;
  }
  tbody tr th {
      vertical-align: middle;
  }
  tbody tr:nth-child(3) td:nth-child(3) {
  }
}
.reveal table.old_paradigm_table.new.visible {
  border-spacing: 0rem;
  tr > td {
    border-radius: 0;
    border: 0 !important;
  }
  tbody tr:nth-child(1) td {
      background: #34548a !important;
  }
  tbody tr:nth-child(2) td {
      background: #0f4b6e !important;
  }
  tbody tr:nth-child(3) td {
      background: #5a4a78 !important;
  }
}
</style>
{% endblock %}

{% block theme %}
import '/themes/tokyonight-light.scss'
import 'highlight.js/styles/tokyo-night-dark.css'
{% endblock %}

{% block slides %}
<script type="module">
import Reveal from 'reveal.js';
Reveal.on( 'fragmentshown', event => {
  // event.fragment = the fragment DOM element
  var line_numbers = event.fragment.dataset.lineNumbers;
  var elem1 = document.getElementById("special1");
  var elem2 = document.getElementById("special2");
  if (line_numbers && line_numbers == "8,13,14,15,18,19") {
    elem1.style.opacity = 1;
    elem1.style.visibility = 'inherit';
  }
  if (line_numbers && line_numbers == "42") {
    elem1.style.opacity = 0;
    elem1.style.visibility = 'hidden';
    elem2.style.opacity = 1;
    elem2.style.visibility = 'inherit';
  }
} );
Reveal.on( 'fragmenthidden', event => {
  // event.fragment = the fragment DOM element
  var line_numbers = event.fragment.dataset.lineNumbers;
  var elem1 = document.getElementById("special1");
  var elem2 = document.getElementById("special2");
  if (line_numbers && line_numbers == "8,13,14,15,18,19") {
    elem1.style.opacity = 0;
    elem1.style.visibility = 'hidden';
  }
  if (line_numbers && line_numbers == "42") {
    elem1.style.opacity = 1;
    elem1.style.visibility = 'inherit';
    elem2.style.opacity = 0;
    elem2.style.visibility = 'hidden';
  }
} );
</script>

<section>
  <section class="center">
    <a href="https://github.com/ucb-bar">
      <img src="./figs/logos/BAR_vertical_logo.svg" class="image" style="height: 100px;">
    </a>
    <a href="https://github.com/ucb-bar/chipyard">
      <img src="./figs/logos/chipyard_logo.svg" class="image" style="height: 100px;">
    </a>
    <h2 class="fragment">The Next Paradigm of SoC Design</h2>
    <h3>Chipyard Overview + Calyx Integration Demo</h3>
    <h4 style="font-weight:normal;">
      Joonho Whangbo, Vighnesh Iyer, Sophia Shao, Krste Asanović, Bora Nikolić (UC Berkeley)
    </h4>
    <h5 style="font-weight:normal;">
      LATTE 2024
    </h5>
  </section>
  <section>
    <h2>Talk Overview</h2>
    <ol>
      <li class="fragment">The existing paradigm of hardware design</li>
      <li class="fragment">What could come next? A view of the next paradigm of hardware design</li>
      <li class="fragment">Recent efforts to build the next paradigm
        <ul>
          <li class="fragment">New HDLs and design abstractions</li>
          <li class="fragment">New simulators</li>
          <li class="fragment">New SoC design frameworks</li>
        </ul>
      </li>
      <li class="fragment">What's still missing? Why are we not in the new age of hardware design?
        <ul>
          <li>It's a lot more than just the frontend language: PPA iteration cycle, verification, other stuff</li>
        </ul>
      </li>
      <li class="fragment">A sketch of what matters to hardware designers and our broad vision

      </li>
    </ol>
  </section>
</section>

<section>
  <section class="center">
    <h1>The Existing Paradigm of Hardware Design</h1>
    <h2>Seen in Industry</h2>
  </section>

  <section>
    <h2>People and Organization</h2>

    <table class="old_paradigm_table">
      <thead>
      <tr>
        <th></th>
        <th></th>
        <th colspan="5">Teams within an SoC Design Organization</th>
      </tr>
      <tr style="text-align: center;">
        <th></th>
        <th></th>
        <th>Spec / Arch</th>
        <th>Perf Modeling</th>
        <th>RTL</th>
        <th>DV</th>
        <th>PD</th>
      </tr>
      </thead>
      <tbody>
      <tr>
        <th rowspan="3" style="vertical-align: middle;">Design block</th>
        <th>Core</th>
        <td class="bg-red"></td>
        <td class="bg-orange"></td>
        <td></td>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <th>LLC</th>
        <td class="bg-red"></td>
        <td class="bg-orange"></td>
        <td></td>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <th>NPU</th>
        <td class="bg-red"></td>
        <td class="bg-orange"></td>
        <td></td>
        <td></td>
        <td></td>
      </tr>
      </tbody>
    </table>

    <ul>
      <li class="fragment">Highly specialized and large workforce</li>
      <li class="fragment">Teams are separated by function rather than design block</li>
      <li class="fragment">Duplicated work between specification, modeling, and RTL</li>
      <li class="fragment">Little interaction between teams</li>
      <li class="fragment">Complex tools and abstractions make transition between functions difficult</li>
    </ul>
  </section>

  <section>
    <h2>Specification</h2>
    <div class="center fragment">
      <img class="image" src="./figs/dynamic/latte24/specification.svg" />
      <!--<p><em>Insert picture of random excel spreadsheets, AXI spec documents, DDR state machines</em></p>-->
    </div>

    <ul>
      <li class="fragment">English, Excel, and drawing specs are the norm</li>
      <li class="fragment">Simulators, models, and verification collateral are handcrafted rather than generated</li>
      <li class="fragment">Translation errors due to undefined behaviors and misinterpretation are common</li>
    </ul>
  </section>

  <section>
    <h2>Languages + Semantics</h2>
    <div class="center fragment">
      <img class="image no-margin" src="./figs/dynamic/latte24/typical_flow.svg" />
      <!--<figcaption class="small">A pretty typical flow</figcaption>-->
      <!--<p><em>Insert picture of ugly SystemVerilog macros, Perl generators</em></p>-->
    </div>

    <!--
    - ill defined / complex semantics, mixing simulation and synthesizable abstractions
    - multiple abstractions can only be blackboxed at the lowest level (practically)
    - massive monolithic simulation/emulation tools
    - macros on top of macros on top of web of Perl scripts
    -->
    <ul class="small">
      <li class="fragment">Most design is done at the RTL abstraction in Verilog/VHDL</li>
      <li class="fragment">Limitations of these languages lead to a tower of macros on top of macros on top of a web of Perl</li>
      <li class="fragment">Simulation / synthesis semantics mismatch</li>
      <li class="fragment">Compositional semantics of mixing multiple abstractions isn't defined. Everything is lowered to RTL</li>
      <li class="fragment">Simulation / emulation tools are massive monolithic blobs</li>
    </ul>
  </section>

  <section>
    <h2>SoC Integration / Construction</h2>
    <div class="center fragment">
      <img class="image no-margin" src="./figs/dynamic/latte24/soc_construction.svg" />
      <!--<p><em>Image of Makefile calling other Makefiles and being wrapped in yet another custom build system</em></p>-->
    </div>

    <!--
    - web of scripts and build systems, config systems on top of config systems
    -->
    <ul>
      <li class="fragment">Composing IP correctly is hard. Satisfying global constraints, verifying every interface conforms, parameter propagation</li>
      <li class="fragment">SoC construction described in ad-hoc phases with yaml on top of Makefiles on top of Makefiles</li>
      <li class="fragment">Collateral emission at block and SoC level must understand the configuration of every IP</li>
    </ul>
  </section>

  <section>
    <h2>Iteration Speed</h2>

    <!--
      - it's not worth mentioning that industry uses handcrafted tools - i think that's not too related to iteration speed issues
    -->

    <div class="center">
      <img class="image no-margin" src="./figs/dynamic/latte24/iteration_speeds.svg" />
      <!--<p><em>Image of iteration speeds as they exist currently. few minutes from design change to elab (for Chipyard), 10s of minutes for HLS. time for RTL sim + eval. time for firesim fpga eval. time for PD flow for power/area.</em></p>-->
    </div>

    <ul>
      <li class="fragment">Each new layer of tools adds latency from making a change to evaluation</li>
      <li class="fragment">Current generation of tools has ad-hoc support for incremental compilation of the design and simulator</li>
      <li class="fragment">It's well known that low iteration speed hampers developer productivity</li>
    </ul>
  </section>

  <!--<section>
    <h2>Beauty / Elegance</h2>

    <ul>
      <li>Compare / contrast SystemC HLS vs Halide or EXO as an example</li>
      <li>How else can we demonstrate the lack of beauty?</li>
    </ul>
  </section>-->
</section>

<section>
  <section class="center">
    <h1>The Next Paradigm Shift of Hardware Design</h1>
  </section>

  <section>
    <h2>Flat Organization</h2>

    <table class="old_paradigm_table fragment custom new">
      <thead>
      <tr>
        <th></th>
        <th></th>
        <th colspan="5">Teams within an SoC Design Organization</th>
      </tr>
      <tr style="text-align: center;">
        <th></th>
        <th></th>
        <th>Spec / Arch</th>
        <th>Perf Modeling</th>
        <th>RTL</th>
        <th>DV</th>
        <th>PD</th>
      </tr>
      </thead>
      <tbody>
      <tr>
        <th rowspan="3" style="vertical-align: middle;">Design block</th>
        <th>Core</th>
        <td class="bg-red"></td>
        <td class="bg-orange"></td>
        <td></td>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <th>LLC</th>
        <td class="bg-red"></td>
        <td class="bg-orange"></td>
        <td></td>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <th>NPU</th>
        <td class="bg-red"></td>
        <td class="bg-orange"></td>
        <td></td>
        <td></td>
        <td></td>
      </tr>
      </tbody>
    </table>

    <ul>
      <li class="fragment">Agile, small, and generalist workforce</li>
      <li class="fragment">Teams are specialized by design block rather than function</li>
      <!--<li>Teams collaborate across functions</li>-->
      <li class="fragment">Design and specification artifacts are reused and contain semantics that span from specification to PD</li>
      <li class="fragment">Higher level abstractions enable productivity across the stack</li>
    </ul>
  </section>

  <section>
    <h2>Clean Interop of Multiple Abstractions</h2>

    <div class="container" style="grid-template-columns: 1fr 1fr;">
      <div class="fragment"><img src="./figs/latte24/esp_flow.png" /></div>
      <div class="fragment">
    <pre><code class="scala" data-trim data-line-numbers>
class GCDMMIOBlackBox(val w: Int)
  extends BlackBox(Map("WIDTH" -> IntParam(w)))
  with HasBlackBoxResource
  with HasGCDIO
{
  addResource("/vsrc/GCDMMIOBlackBox.v")
}
    </code></pre>
      </div>
    </div>

    <ul>
      <li class="fragment">We are still far away from realizing true multi-abstraction interop
        <ul>
        <li class="fragment">Blackboxing isn't true interop</li>
        <li class="fragment">Designers can benefit from fine-grained interop</li>
        </ul>
      </li>
    </ul>
    <dl>
      <dt class="fragment">Elaboration time interop</dt><dd class="fragment">The practical mechanism (FFI) of invoking sub-generators</dd>
      <dt class="fragment">Runtime interop</dt><dd class="fragment">Runtime interaction semantics between abstractions</dd>
    </dl>
  </section>

  <section>
    <h2>Rapid Iteration Across the Design Flow</h2>

    <div class="container image no-padding no-margin" style="grid-template-columns: 1fr 1fr;">
      <div class="fragment"><img width="60%" src="./figs/latte24/livesynth.png" /></div>
      <div class="fragment"><img src="./figs/latte24/livehd.png" /></div>
      <!--<p><em>Modified image of iteration speeds. Make it clear that an fine-grained accuracy vs fidelity tradeoff is possible.</em></p>-->
    </div>
    <div class="center">
      <figcaption class="fragment small">LiveSynth and LiveHD make strong drive towards rapid iteration.</figcaption>
    </div>

    <ul>
      <li class="fragment">Focus not only on performance (throughput) of existing frontend + simulation tools, but also on <em>startup latency</em></li>
      <li class="fragment">It's a lot more than just the frontend language: PPA evaluation, verification, and simulation is critical</li>
      <!--<li><em>Call out LiveHD, LiveSim, LiveSynth for being the only works that tackle this critical problem</em></li>-->
    </ul>
  </section>

  <section>
    <h2>Main Ideas</h2>
    <dl>
      <dt class="fragment">Frontends</dt>
      <dd class="fragment">Mixed-abstraction, interop semantics, ergonomic external module integration, embedding PD/power/verification collateral, rewrite/spec/compiler generation</dd>
      <dt class="fragment">IRs</dt>
      <dd class="fragment">Preservation of semantics, graph-oriented representation</dd>
      <dt class="fragment">Tools / Simulators</dt>
      <dd class="fragment">Low latency iteration cycle (incremental), full spectrum (from specification to PD)</dd>
    </dl>
  </section>
</section>

<section>
  <section class="center">
    <h1>Showcase of Work Towards the Next Paradigm</h1>
  </section>

  <section>
    <h2>New HDLs and Design Abstractions</h2>
    <dl>
      <dt class="fragment">Intermediate representations</dt>
      <dd class="fragment small"><a href="https://github.com/chipsalliance/firrtl-spec">FIRRTL</a>, <a href="https://github.com/fabianschuiki/llhd">LLHD</a>, <a href="https://circt.llvm.org/docs/Dialects/">Circt</a> <small>(affine, handshake, ssp, pipeline, fsm, dc)</small>, <a href="https://dl.acm.org/doi/pdf/10.1145/3623278.3624767">HIR</a>, <a href="https://github.com/masc-ucsc/livehd/tree/master/lgraph">LGraph</a>/<a href="https://masc.soe.ucsc.edu/docs/woset19b.pdf">LNAST</a>, <a href="https://github.com/YosysHQ/yosys/blob/main/kernel/rtlil.h">Yosys RTLIL</a>, <a href="https://dl.acm.org/doi/abs/10.1145/3453483.3454075">Reticle</a></dd>
      <dt class="fragment">RTL-level</dt>
      <dd class="fragment small"><strong>Chisel</strong>, SpinalHDL (Scala) | Lava, Blarney (Haskell) | Amaranth, MyHDL, PyMTL3, <a href="https://github.com/UCSBarchlab/PyRTL">PyRTL</a>, Magma, (Python) | HardCaml (OCaml) | <a href="https://intel.github.io/rohd-website/">ROHD</a> (Dart) | pyrope, Veryl (freestanding)</dd>
      <dt class="fragment">Dataflow</dt>
      <dd class="fragment"><a href="https://spade-lang.org/">Spade</a>, Shakeflow, DFiant, Verilog-TL, PipelineC</dd>
      <dt class="fragment">Control flow synthesis</dt>
      <dd class="fragment">Calyx, XLS, Bluespec, <a href="https://github.com/mit-plv/koika">Koika</a>, <a href="https://clash-lang.org/">Clash</a><sup>*</sup></dd>
      <dt class="fragment">Accelerator design languages</dt>
      <dd class="fragment">Spatial, Dahlia, <a href="https://dl.acm.org/doi/abs/10.1145/3352460.3358292">μIR</a>, HeteroCL, <a href="https://arxiv.org/pdf/2404.04815.pdf">Allo</a></dd>
      <dt class="fragment">General HLS</dt>
      <dd class="fragment">SystemC (Catapult), C++ (<a href="">LegUp</a>, <a href="https://github.com/Xilinx/HLS">Vitis HLS</a>)</dd>
    </dl>

    <p class="center fragment">Enabling higher hardware design productivity. </p>
  </section>

  <section>
    <h2>New Simulators</h2>
    <dl>
      <dt class="fragment">Higher-abstraction simulators</dt>
      <dd class="fragment"><a href="https://docs.calyxir.org/debug/cider.html">Cider (Calyx)</a>, <a href="https://people.csail.mit.edu/bthom/asplos21-1.pdf">Cuttlesim</a> (Koika)</dd>
      <dt class="fragment">RTL SW simulators</dt>
      <dd class="fragment"><a href="https://www.veripool.org/verilator/">Verilator</a>, <a href="https://github.com/circt/arc-tests">Arcilator</a>, <a href="https://yosyshq.readthedocs.io/projects/yosys/en/latest/cmd/write_cxxrtl.html">CXXRTL</a>, <a href="https://github.com/chipsalliance/treadle">Treadle</a>, ESSENT, RepCut, Khronos</dd>
      <dt class="fragment">HW accelerated RTL simulators</dt>
      <dd class="fragment small"><strong><a href="https://fires.im/">FireSim</a></strong>, Manticore (FPGA) | RTLFlow (GPU) | <a href="https://dl.acm.org/doi/abs/10.1145/3613424.3614257">ASH</a><sup>*</sup> (ASIC) | <a href="https://arxiv.org/abs/2403.04714">Parendi</a> (Graphcore IPU)</dd>
    </dl>
    <p class="center fragment">Iteration speed is critical; simulation is the workhorse of HW design. SW RTL simulation isn't at its limit! HW accelerated RTL simulation has been scantly explored.</p>
  </section>

  <section>
    <h2>New SoC Design Frameworks</h2>
    <ul class="fragment">
      <li><strong><a href="https://github.com/ucb-bar/chipyard">Chipyard</a></strong>: Chisel-based, cores (Rocket, BOOM, CVA6), accelerators (Gemmini, NVDLA), memory system + NoC</li>
      <li><a href="https://www.esp.cs.columbia.edu/">ESP</a>: Tile based SoC architecture, cores (CVA6, Ibex), accelerators (Verilog blackboxing), memory system + NoC</li>
      <li><a href="http://parallel.princeton.edu/openpiton/">OpenPiton</a>: Ariane + memory / uncore components</li>
      <li><a href="https://github.com/pulp-platform/pulp">PULP</a>: Cores (RISCY, zero-riscy), ???</li>
      <li><a href="https://github.com/black-parrot/black-parrot">BlackParrot</a>: ???</li>
      <li><a href="https://github.com/OpenXiangShan/XiangShan">Xiangshan</a>: High performance OoO RISC-V core + L2</li>
    </ul>

    <p class="center fragment">Full system evaluation at RTL-level. SoC level parameterization and integration of external IP.</p>
  </section>
</section>

<section>
  <section class="center">
    <h2>Berkeley's attempt<br>on the new HW design paradigm</h2>
    <ul>
      <li class="fragment">The RTL first methodology (just go write RTL).</li>
    </ul>
  </section>

  <section class="center">
    <h3>Typical hardware design cycle</h3>
    <div class="container" style="grid-template-columns: 1.0fr 1.4fr;">
      <div class="fragment">
        <img src="./figs/latte24/design-process.svg" />
      </div>
      <div>
        <font size="6">
        <ul>
          <li class="fragment">Iterate over a design point in various abstractions.</li>
          <li class="fragment">You can get feedback from lower level abstractions.</li>
          <li class="fragment">You are likely to run <strong>a lot of simulations</strong> in order to get functionality and performance correct.</li>
        </ul>
        </font>
      </div>
    </div>
  </section>

  <section class="center">
    <h3>Problems of modeling</h3>
    <div class="container" style="grid-template-rows: 0.2fr 0.7fr;">
    <div>
      <img class="fragment" data-fragment-index="0" height=300px; src="./figs/latte24/modeling-errors.png" />
    </div>
    <div>
      <ul>
        <li class="fragment" data-fragment-index="0">Prone to errors.</li>
        <li class="fragment">Redundant work.</li>
      </ul>
    </div>
  </section>

  <section class="center">
    <h3>RTL first design methodology</h3>
    <div class="container" style="grid-template-columns: 1.0fr 1.4fr;">
      <div class="fragment">
        <img src="./figs/latte24/design-process-rtl-first.svg" />
      </div>
      <div>
        <font size="6">
        <ul>
          <li class="fragment">Modeling is required because <strong>RTL writing is hard</strong>.</li>
          <li class="fragment">Make RTL writing so easy that we can just do modeling with RTL.</li>
          <li class="fragment">Model large systems with high evaluation fidelity!</li>
        </ul>
        </font>
      </div>
    </div>
  </section>

  <section class="center">
    <h3>Our efforts towards RTL first</h3>
    <ul>
      <li class="fragment">Design language : Chisel & FIRRTL</li>
      <li class="fragment">SoC evaluation framework : Chipyard & FireSim</li>
    </ul>
  </section>

  <section class="center">
    <h2>Chisel</h2>
    <ul>
      <li class="fragment">HDL embedded in Scala.</li>
      <li class="fragment">Metaprogramming on top of the RTL abstraction.</li>
      <ul>
        <li class="fragment">Scala enables high expressiveness compared to SV.</li>
        <li class="fragment">Makes it much easier to read and write RTL.</li>
      </ul>
    </ul>
  </section>

  <section data-auto-animate>
    <h3>Reduced Sum : System Verilog</h3>
    <pre data-id="code-animation"><code class="verilog" data-trim data-line-numbers>
    module MyModule
      #(parameter N, M)
      (
        input  [N-1:0] a [0:M-1],
        output [N-1:0] sum
      );
      ...

    endmodule
    </code></pre>
  </section>

  <section data-auto-animate>
    <h3>Reduced Sum : System Verilog</h3>
    <pre data-id="code-animation"><code class="verilog" data-trim data-line-numbers="8-18">
    module MyModule
      #(parameter N, M)
      (
        input  [N-1:0] a [0:M-1],
        output [N-1:0] sum
      );

      reg [N-1:0] tmp [0:M];

      tmp[0] = a[0];
      sum = tmp[M];

      genvar i;
      generate
        for (i = 1; i &lt; M; i = i + 1) begin
          tmp[i] = tmp[i-1] + a[i];
        end
      endgenerate
    endmodule
    </code></pre>
  </section>

  <section data-auto-animate>
    <h2>Reduced Sum : Chisel</h2>
    <pre data-id="code-animation"><code class="scala" data-trim data-line-numbers>
    class MyModule(N: Int, M: Int) extends Module {
      val io = IO(new Bundle {
        val a = Vec(M, Input(UInt(N.W)))
        val sum  = Output(UInt(N.W))
      })
      ...
    }
    </code></pre>
  </section>

  <section data-auto-animate>
    <h2>Reduced Sum : Chisel</h2>
    <pre data-id="code-animation"><code class="scala" data-trim data-line-numbers="6">
    class MyModule(N: Int, M: Int) extends Module {
      val io = IO(new Bundle {
        val a = Vec(M, Input(UInt(N.W)))
        val sum  = Output(UInt(N.W))
      })
      io.sum := io.a.reduce(_ + _)
    }
    </code></pre>
  </section>

  <section class="center">
    <h2>Chisel Implications</h2>
    <ul>
      <li class="fragment">Much less verbose when describing HW.</li>
      <li class="fragment">Easier to compose modules programmatically.</li>
      <li class="fragment">eDSL : enables us to use existing tools around the host language.</li>
      <ul>
        <li class="fragment">Package manager.</li>
        <li class="fragment">Build systems.</li>
        <li class="fragment">LSP.</li>
      </ul>
    </ul>
  </section>

  <section class="center">
    <h2>FIRRTL</h2>
    <ul>
      <li class="fragment">Intermediate representation for Chisel.</li>
      <li class="fragment">Designed to represent the generated circuit after Chisel's elaboration (after all meta programming has executed).</li>
      <li class="fragment">SSA style in memory representation.</li>
    </ul>
  </section>

  <section data-auto-animate>
    <h2>Reduced Sum : FIRRTL</h2>
    <pre data-id="code-animation"><code class="" data-trim data-line-numbers>
    circuit MyModule :
      module MyModule :
        ...
    </code></pre>
  </section>

  <section data-auto-animate>
    <h2>Reduced Sum : FIRRTL</h2>
    <pre data-id="code-animation"><code class="" data-trim data-line-numbers="2-5">
    circuit MyModule :
      module MyModule :
        input clock : Clock
        input reset : UInt&lbrack;1&rbrack;
        output io : { flip a : UInt&lbrack;4&rbrack;[4], sum : UInt&lbrack;4&rbrack;}

        node _io_sum_T = add(io.a[0], io.a[1]) @[MyModule.scala 14:27]
        node _io_sum_T_1 = tail(_io_sum_T, 1) @[MyModule.scala 14:27]
        node _io_sum_T_2 = add(_io_sum_T_1, io.a[2]) @[MyModule.scala 14:27]
        node _io_sum_T_3 = tail(_io_sum_T_2, 1) @[MyModule.scala 14:27]
        node _io_sum_T_4 = add(_io_sum_T_3, io.a[3]) @[MyModule.scala 14:27]
        node _io_sum_T_5 = tail(_io_sum_T_4, 1) @[MyModule.scala 14:27]
        io.sum &lt;= _io_sum_T_5 @[MyModule.scala 14:10]
    </code></pre>
    <p>FIRRTL resembles your circuit.</p>
  </section>

  <section data-auto-animate>
    <h2>Reduced Sum : FIRRTL</h2>
    <pre data-id="code-animation"><code class="" data-trim data-line-numbers="7-13">
    circuit MyModule :
      module MyModule :
        input clock : Clock
        input reset : UInt&lbrack;1&rbrack;
        output io : { flip a : UInt&lbrack;4&rbrack;[4], sum : UInt&lbrack;4&rbrack;}

        node _io_sum_T = add(io.a[0], io.a[1]) @[MyModule.scala 14:27]
        node _io_sum_T_1 = tail(_io_sum_T, 1) @[MyModule.scala 14:27]
        node _io_sum_T_2 = add(_io_sum_T_1, io.a[2]) @[MyModule.scala 14:27]
        node _io_sum_T_3 = tail(_io_sum_T_2, 1) @[MyModule.scala 14:27]
        node _io_sum_T_4 = add(_io_sum_T_3, io.a[3]) @[MyModule.scala 14:27]
        node _io_sum_T_5 = tail(_io_sum_T_4, 1) @[MyModule.scala 14:27]
        io.sum &lt;= _io_sum_T_5 @[MyModule.scala 14:10]
    </code></pre>
    <p>Metaprogramming has executed</p>
  </section>

  <section data-auto-animate>
    <h3>Cool things that FIRRTL enables</h3>
    <ul>
      <li class="fragment">Netlist manipulation : scan-chains, reparenting modules (for PD).</li>
      <li class="fragment">Error checking, generic compiler optimizations.</li>
      <ul>
        <li class="fragment">Combinational loop detection.</li>
        <li class="fragment">DCE, CSE, Const Prop.</li>
      </ul>
    </ul>
  </section>

  <section data-auto-animate>
    <h3>Cool things that FIRRTL enables</h3>
    <ul>
      <li class="fragment">FAME transformations and FireSim.</li>
      <figure>
        <img class="fragment" src="./figs/latte24/li-bdn-transformed.svg" />
        <figcaption class="fragment">Bold lines : Target design<br>Dashed lines : Timing control logic</figcaption>
      </figure>
    </ul>
  </section>

  <section class="center">
    <h2>FIRRTL Implications</h2>
    <ul>
      <li class="fragment">Enables you to programmatically traverse/modify the netlist.</li>
      <li class="fragment">Given a single design, you are now able to generate various collateral by applying different compiler passes.</li>
    </ul>
  </section>

  <section class="center">
    <h2>What is Chipyard</h2>
    <div class="container" style="grid-template-columns: 1.4fr 1.0fr;">
    <div>
      <img src="./figs/latte24/soc-arch.svg"/>
    </div>
    <div>
      <font size="5">
      <ul>
        <li class="fragment">Generator based SoC design framework.</li>
        <li class="fragment">Easy to configure a diverse set of SoC design space.</li>
        <ul>
          <li class="fragment">IP shop for RISC-V cores, accelerators, memory elements and the bus hierarchy.</li>
        </ul>
        <li class="fragment">Ensures correct composition of the modules during elaboration time.</li>
        <ul>
          <li class="fragment">Parameter validity, SoC address space.</li>
        </ul>
      </ul>
      </font>
    </div>
  </section>

  <section class="center">
    <h2>FireSim at 35,000 feet</h2>
    <div class="container" style="grid-template-columns: 1.0fr 1.4fr;">
    <div>
      <ul>
        <img class="fragment" data-fragment-index="0" height=400px; src="./figs/latte24/firesim.svg" />
      </ul>
    </div>
    <div>
      <font size="6">
      <ul>
        <li class="fragment" data-fragment-index="0">FPGA accelerated RTL simulation platform.</li>
        <li class="fragment">Enables us to perform end-to-end performance evaluation of our designs by running entire RISC-V binaries.</li>
        <li class="fragment">Useful for discovering bugs that appear trillions of cycles into simulation.</li>
      </ul>
      </font>
    </div>
  </section>

{# <section class="center"> #}
{# <h2>Host decoupling</h2> #}
{# <div class="container" style="grid-template-columns: 1.2fr 1.0fr;"> #}
{# <div class="r-stack"> #}
{# <img class="fragment fade-in-then-out" data-fragment-index="0" src="./figs/latte24/firesim-before-transform.png"/> #}
{# <img class="fragment fade-in-then-out" data-fragment-index="1" src="./figs/latte24/firesim-after-transform.png"/> #}
{# <img class="fragment"                  data-fragment-index="2" src="./figs/latte24/firesim-mapped.png"/> #}
{# </div> #}
{# <div> #}
{# <font size="5"> #}
{# <ul> #}
{# <li class="fragment" data-fragment-index="0">Starting with your target.</li> #}
{# <li class="fragment" data-fragment-index="1">Wrap the target RTL in a latency insensitive wrapper.</li> #}
{# <li class="fragment" data-fragment-index="1">Attach a DRAM timing model using host FPGA resources.</li> #}
{# <li class="fragment" data-fragment-index="1">These steps are automated by the FIRRTL compiler.</li> #}
{# <li class="fragment" data-fragment-index="2">Map the simulation onto the host FPGA.</li> #}
{# <li class="fragment" data-fragment-index="2">SoC now sees 100 cycles of DRAM latency!</li> #}
{# </ul> #}
{# </font> #}
{# </div> #}
{# </div> #}
{# </section> #}

  <section class="center">
    <h3>Overview of the Current Infrastructure</h3>
    <div class="container" style="grid-template-columns: 1.0fr 1.0fr;">
      <div class="fragment">
        <img src="./figs/latte24/tool-stack.svg" />
      </div>
      <div>
        <font size="6">
        <ul>
          <li class="fragment">Chisel & FIRRTL : Expressive frontend and flexible IR.</li>
          <li class="fragment">Chipyard : Composable SoC generator framework.</li>
          <li class="fragment">FireSim : Fast RTL simulation.</li>
          <li class="fragment">Enabled countless research projects from both industry and academia for the last 5+ years.</li>
        </ul>
        </font>
      </div>
    </div>
  </section>
</section>

{# ----------------------------------------------------------------------- #}

<section>
  <section class="center">
    <h3>Current methodology of mixed abstraction flow</h3>
    <ul>
    <li class="fragment">Demo : How to integrate your own IP to perform full system SoC level evaluation?</li>
    </ul>
  </section>

  <section class="center">
    <h3>Step 1 : Generate RTL from your HDL (e.g. Calyx)</h3>
    <pre data-id="code-animation"><code class="verilog" data-trim>
    component CalyxSumBlackBox(in: 4) -> (out: 4) {
      cells { ... }
      wires { ... }
      control { ... }
    }
    </code></pre>
    <ul>
      <li class="fragment">Given a input, add it three times to itself and output it.</li>
    </ul>
  </section>

  <section class="center">
    <h3>Step 2 : Create a BlackBox Module in Chipyard</h3>
    <div class="container" style="grid-template-columns: 1.0fr 1.5fr;">
      <div>
        <pre data-id="code-animation"><code class="scala" data-trim data-line-numbers>
        class CalyxSumIO(nBits: Int) extends Bundle {
          val clk   = Input(Clock())
          val reset = Input(Bool())

          val in    = Input(UInt(nBits.W))
          val go    = Input(Bool())

          val out   = Output(UInt(nBits.W))
          val done  = Output(Bool())
        }

        class CalyxSumBlackBox(nBits: Int)
            extends BlackBox
            with HasBlackBoxResource {
          val io = IO(new CalyxSumIO(nBits))
          addResource("/vsrc/aggregator.sv")
        }
        </code></pre>
      </div>
      <div>
        <img class="fragment" src="./figs/latte24/calyx-verilog.svg"/>
      </div>
    <div>
  </section>

  <section data-auto-animate>
    <h3>Step 3 : Generate a MMIO wrapper in Chipyard</h3>
    <div class="container" style="grid-template-columns: 1.0fr 1.5fr;">
      <div>
        <font size="4">
        <pre data-id="code-animation"><code class="scala" data-trim data-line-numbers="1-35|37-73">
        case class CalyxSumParams(
          address: BigInt = 0x5000,
          qDepth: Int = 4,
          nBits: Int = 4,
          nSum: Int = 3)

        case object CalyxSumKey extends Field[Option[CalyxSumParams]](None)

        class CalyxSumMMIOWrapper(
          params: CalyxSumParams, beatBytes: Int
        )(
          implicit p: Parameters
        ) extends ClockSinkDomain(ClockSinkParameters())(p) {
          val device = new SimpleDevice("calyx-sum", Seq("ucbbar,calyx-sum"))
          val node = TLRegisterNode(Seq(AddressSet(params.address, 4096-1)),
                                        device,
                                        "reg/control",
                                        beatBytes=beatBytes)

          val nBits = params.nBits
          val nSum  = params.nSum

          override lazy val module = new MMIOWrapperImpl

          class MMIOWrapperImpl extends Impl with HasCalyxSumTopIO {
            val io = IO(new CalyxSumTopIO)

            withClockAndReset(clock, reset) {
              val bb    = Module(new CalyxSumBlackBox(nBits))
              val in_q  = Module(new Queue(UInt(nBits.W), params.qDepth))
              val out_q = Module(new Queue(UInt(nBits.W), params.qDepth))

              val go = RegInit(false.B)
              val cnt = RegInit(0.U(8.W))

              switch (go) {
                is (false.B) {
                  when (in_q.io.count > 0.U && out_q.io.enq.ready) {
                    go := true.B
                    cnt := 0.U
                  }
                }

                is (true.B) {
                  when (bb.io.done) {
                    go := false.B
                  }
                }
              }

              bb.io.clk   := clock
              bb.io.reset := reset.asBool
              bb.io.go    := go
              bb.io.in    := in_q.io.deq.bits
              in_q.io.deq.ready := bb.io.done

              out_q.io.enq.bits  := bb.io.out
              out_q.io.enq.valid := bb.io.done
              io.done := bb.io.done

              when (bb.io.done) {
                assert(out_q.io.enq.ready)
              }

              node.regmap(
                0x00 -> Seq(RegField.r(1,     in_q.io.enq.ready)),
                0x04 -> Seq(RegField.w(nBits, in_q.io.enq)),
                0x08 -> Seq(RegField.r(1,     out_q.io.deq.valid)),
                0x0C -> Seq(RegField.r(nBits, out_q.io.deq))
              )
            }
          }
        }
        </code></pre>
        </font>
      </div>
      <div>
        <img class="fragment" src="./figs/latte24/calyx-wrapped.svg"/>
      </div>
    </div>
  </section>

  <section data-auto-animate>
    <h3>Step 4 : Add MMIO ports to the bus</h3>
    <div class="container" style="grid-template-columns: 1.0fr 1.5fr;">
      <div>
        <font size="4">
          <pre data-id="code-animation"><code class="scala" data-trim data-line-numbers="">
          trait CanHaveMMIOCalyxSum { this: BaseSubsystem =>
            private val pbus = locateTLBusWrapper(PBUS)

            val calyx_sum_done = p(CalyxSumKey) match {
              case Some(params) => {
                val cs = LazyModule(new CalyxSumMMIOWrapper(params, pbus.beatBytes)(p))
                cs.clockNode := pbus.fixedClockNode
                pbus.coupleTo("calyx_sum_mmio_wrapper") {
                  cs.node := TLFragmenter(pbus.beatBytes, pbus.blockBytes) := _
                }

                // Add port to DigitalTop (just for fun)
                val calyx_sum_done = InModuleBody {
                  val done = IO(Output(Bool())).suggestName("calyx_sum_done")
                  done := cs.module.io.done
                  done
                }
                Some(calyx_sum_done)
              }
              case None => None
            }
          }

          // DOC include start: DigitalTop
          class DigitalTop(implicit p: Parameters) extends ChipyardSystem
            ...
            // Enables optionally adding a Calyx generated module as a MMIO device
            with chipyard.example.CanHaveMMIOCalyxSum
          {
            override lazy val module = new DigitalTopModule(this)
          }
          </code></pre>
        </font>
      </div>
      <div>
        <img class="fragment" src="./figs/latte24/demo-create-port.svg" />
      </div>
    </div>
  </section>

  <section data-auto-animate>
    <h3>Step 6 : Configure your SoC to use the MMIO module</h3>
    <div class="container" style="grid-template-columns: 1.0fr 1.5fr;">
      <div>
        <font size="5">
        <pre data-id="code-animation"><code class="scala" data-trim data-line-numbers>
        class WithCalyxSum extends Config((site, here, up) => {
          case CalyxSumKey => Some(CalyxSumParams())
        })

        class CalyxSumRocketConfig extends Config(
          new chipyard.example.WithCalyxSum ++
          new freechips.rocketchip.subsystem.WithNBigCores(1) ++
          new chipyard.config.AbstractConfig)
        </code></pre>
        </font>
      </div>
      <div>
        <img class="fragment" src="./figs/latte24/demo-overall-soc.svg" />
      </div>
    </div>
    <p>At this point, the SoC level configuration is finished</p>
  </section>

  <section data-auto-animate>
    <h3>Step 7 : Write software to talk to the MMIO device</h3>
    <font size="4">
    <pre data-id="code-animation"><code class="cpp" data-trim data-line-numbers="1-36|21-57">
    ...

    #define CALYX_SUM_BASE 0x5000
    #define CALYX_SUM_ENQ_RDY  (CALYX_SUM_BASE + 0)
    #define CALYX_SUM_ENQ_BITS (CALYX_SUM_BASE + 4)
    #define CALYX_SUM_DEQ_VAL  (CALYX_SUM_BASE + 8)
    #define CALYX_SUM_DEQ_BITS (CALYX_SUM_BASE + 12)


    static inline int calyx_sum_enq_ready() {
      int rdy = reg_read32(CALYX_SUM_ENQ_RDY);
      printf("calyx_sum_enq_ready: %d\n", rdy);
      return (rdy != 0);
    }

    static inline void calyx_sum_send_input(int val) {
      while (!calyx_sum_enq_ready());
      printf("sending input: %d\n", val);
      reg_write32(CALYX_SUM_ENQ_BITS, val & 0xf);
      printf("sending input done\n");
    }

    static inline int calyx_sum_deq_valid() {
      int val = reg_read32(CALYX_SUM_DEQ_VAL);
      printf("calyx_sum_deq_val: %d\n", val);
      return (val != 0);
    }

    static inline int calyx_sum_get_output() {
      while (!calyx_sum_deq_valid());
      return reg_read32(CALYX_SUM_DEQ_BITS);
    }

    ...

    #define TEST_SIZE 3

    int main() {

      int test_inputs[TEST_SIZE] = {1, 2, 3};

      for (int i = 0; i &lt; TEST_SIZE; i++) {
        calyx_sum_send_input(test_inputs[i]);

        int out = calyx_sum_get_output();
        int expect = test_inputs[i] * 3;

        if (out != expect) {
          printf("expect %d got %d\n", expect, out);
          return 1;
        }
      }
      printf("[*] Test success!\n");
      return 0;
    }
    </code></pre>
    </font>
  </section>

  <section data-auto-animate>
    <h3>Step 8 : Run SoC level integration tests</h3>
    <pre data-id="code-animation"><code class="bash" data-trim data-line-numbers="5">
    cd chipyard/tests
    make
    cd -
    cd chipyard/sims/verilator
    make -j$(nproc) run-binary CONFIG=CalyxSumRocketConfig BINARY=../../tests/calyx-sum.riscv
    </code></pre>
  </section>

  <section class="center">
    <h3>Step 8 : Run SoC level integration tests</h3>
    <img height=500px; src="./figs/latte24/calyx-uartlog.png" />
  </section>

  <section class="center">
    <h2>Resources</h2>
    <div class="container" style="grid-template-columns: 1.0fr 1.0fr;">
      <div>
        <img src="./figs/latte24/chipyard-docs.svg"/>
        <img src="./figs/latte24/firesim-docs.jpg"/>
      </div>
      <div>
        <ul>
          <li><a href="https://chipyard.readthedocs.io/en/stable/">Chipyard docs.</a></li>
          <li><a href="https://docs.fires.im/en/stable/">FireSim docs.</a></li>
          <li><a href="https://fires.im/asplos-2023-tutorial/">Link to previous tutorial recordings</a></li>
        </ul>
      </div>
    </div>
  </section>
</section>

<!-- -------------------------------------------------------------------- -->


<section>
  <section class="center">
    <h2>Why have we not reached the next paradigm?</h2>
  </section>

  <section class="center">
    <h3>Why have we not reached the next paradigm?</h3>
    <ul>
      <li class="fragment">Iteration cycle.</li>
      <ul>
        <li class="fragment">Compile/simulation time.</li>
        <li class="fragment">Fast power/area estimation capabilities.</li>
      </ul>
      <li class="fragment">Utilizing the suitable abstractions.</li>
      <ul>
        <li class="fragment">Design productivity.</li>
        <li class="fragment">IP integration is always at the RTL level.</li>
        <ul>
          <li class="fragment">Ad-hoc blackboxing or DPI interfaces.</li>
          <li class="fragment">Compromising simulation throughput.</li>
        </ul>
      </ul>
      <li class="fragment">Other concerns.</li>
      <ul>
        <li class="fragment">Physical design, verification.</li>
{# specifying clock/reset/power domains should be more explicit (we need to encode upf files in the frontend language) #}
{# Since we are not specifying these semantics, we can't simulate these things. #}
        <li class="fragment">Missing power/clock/reset semantics.</li>
        <li class="fragment">Need a systematic way of generating collateral from specs.</li>
      </ul>
    </ul>
  </section>

  <section class="center">
    <h3>Feature Requests</h3>
    <div class="container" style="grid-template-columns: 1.0fr 1.4fr;">
      <div>
        <img src="./figs/latte24/feature-request.jpg" />
      </div>
      <div>
        <font size="6">
        <ul>
          <li class="fragment">Fast compilation time as well as quick feedback from the backend tools.</li>
          <li class="fragment">Fast simulation that doesn't require hours of compile time.</li>
          <li class="fragment">Support for higher level abstractions to enable designers to work on various levels of abstractions.</li>
        </ul>
        </font>
      </div>
    </div>
  </section>

  <section class="center">
    <h3>Rest of the talk</h3>
    <div class="container" style="grid-template-columns: 1.0fr 1.4fr;">
    <div>
      <img src="./figs/latte24/tool-stack.svg" />
    </div>
    <div>
      <ul>
        <li class="fragment">Our vision for rethinking the end-to-end flow for chip design.</li>
      </ul>
    </div>
    </div>
  </section>
</section>

<!-- -------------------------------------------------------------------- -->

<section>
  <section class="center">
    <h2>Language Frontend</h2>
  </section>

  <section class="center">
    <h3>1. Reducing the Compile time</h3>
  </section>

  <section class="center">
    <h2>Chipyard Compile Steps</h2>
    <ul>
      <li class="fragment">Scala FIRRTL Compiler (SFC) : Compiles the scala sources and generates CHIRRTL.</li>
      <li class="fragment">MLIR FIRRTL Compiler (MFC) : Emits Verilog from CHIRRTL.</li>
      <li class="fragment">Verilator : Verilog to C++ binary.</li>
    </ul>
  </section>

  <section class="center">
    <h2>Chipyard Compile Steps</h2>
    <div class="container" style="grid-template-rows: 0.1fr 0.7fr;">
      <div>
        <font size="5">
        <ul>
          <li class="fragment">Imagine you are working on BOOM...</li>
          <li class="fragment">Waiting 10 minutes every time you find a bug, just to start RTL simulation...</li>
        </ul>
        </font>
      </div>
      <div>
        <img src="./figs/latte24/compile-time.svg" />
      </div>
    </div>
  </section>

  <section data-auto-animate>
    <h2>Incremental First</h2>
    <ul>
      <li class="fragment">Hardware designers want more iterations to perform experiments.</li>
      <li class="fragment">Most of the times, we write the entire module, and make small fixes to the control logic.</li>
    </ul>
    <pre data-id="code-animation"><code class="scala" data-trim data-line-numbers="6">
    class MyModule(N: Int, M: Int) extends Module {
      val io = IO(new Bundle {
        val a = Vec(M, Input(UInt(N.W)))
        val sum  = Output(UInt((N + M - 1).W))
      })
      io.sum := io.a.reduce(_ + _)
    }
    </code></pre>
  </section>

  <section data-auto-animate>
    <h2>Incremental First</h2>
    <pre data-id="code-animation"><code class="scala" data-trim data-line-numbers="6">
    class MyModule(N: Int, M: Int) extends Module {
      val io = IO(new Bundle {
        val a = Vec(M, Input(UInt(N.W)))
        val sum  = Output(UInt((N + M - 1).W))
      })
      io.sum := io.a.reduce(_ +& _)
    }
    </code></pre>
    <p class="fragment">Are you ready to wait 10 more minutes for your code to compile?</p>
  </section>

  <section class="center">
    <h2>Incremental First</h2>
    <ul>
      <li class="fragment">This problem can be solved by adopting the incremental first approach to hardware design.</li>
      <li class="fragment"><strong>Partial compilation & Cacheing.</strong></li>
    </ul>
  </section>

  <section class="center">
    <h2>Incremental First</h2>
    <img src="./figs/latte24/incremental-1.svg" />
  </section>

  <section class="center">
    <h2>Incremental First</h2>
    <img src="./figs/latte24/incremental-2.svg" />
    <ul>
      <li class="fragment">classfiles are cached by the build system of the host language.</li>
      <li class="fragment">Scala : <a href="https://mill-build.com/mill/Intro_to_Mill.html">mill</a></li>
    </ul>
  </section>

  <section class="center">
    <h2>Incremental First</h2>
    <img src="./figs/latte24/incremental-3.svg" style="width:80%;height:auto;"/>
    <ul>
      <li class="fragment">Builder has to manage the cache for the generated output (*.sv).</li>
    </ul>
  </section>

  <section class="center">
    <h2>Incremental First</h2>
    <img src="./figs/latte24/incremental-4.svg" style="width:80%;height:auto;"/>
    <ul>
      <li class="fragment">A1.class is invalidated by the host language build system.</li>
    </ul>
  </section>

  <section class="center">
    <h2>Incremental First</h2>
    <img src="./figs/latte24/incremental-5.svg" style="width:80%;height:auto;"/>
    <ul>
      <li class="fragment">Builder.class investigates A1.class to see if there are any changes made.</li>
    </ul>
  </section>

  <section class="center">
    <h2>Incremental First</h2>
    <ul>
      <li class="fragment">We get halfway there by just utilizing the host buildsystem.</li>
      <li class="fragment">The eDSL interpreter has to perform some tracking mechanism.</li>
    </ul>
  </section>

  <section class="center">
    <h3>2. Reducing the Modeling time</h3>
  </section>

  <section class="center">
    <h2>Mixed Abstractions</h2>
    <ul>
      <li class="fragment">We want to raise the level of abstraction to make HW design easier.</li>
      <ul>
        <li class="fragment">Accelerators, initial prototyping stage, (possibly) the bus hierarchy.</li>
      </ul>
      <li class="fragment">However, we also need lower level abstractions (RTL) when designing an SoC.</li>
      <ul>
        <li class="fragment">High perf cores and caches.</li>
      </ul>
    </ul>
  </section>

  <section class="center">
    <h3>Existing Abstractions</h3>
    <ul>
      <li class="fragment">Gate level : lets ignore this for now...</li>
      <li class="fragment">RTL : Explicitly defining registers and wires (e.g., Verilog, S-Verilog, Chisel).</li>
      <li class="fragment">Calyx : Explicit HW instantiations, imperative control flow.</li>
      <li class="fragment">HLS : High level descriptions, compiler does it all.</li>
    </ul>
  </section>

  <section class="center">
    <h2>Problems with Mixing</h2>
    <div class="container" style="grid-template-columns: 1.0fr 1.4fr;">
      <div>
        <img src="./figs/latte24/oil-water.jpg" />
      </div>
      <div>
        <font size="6">
        <ul>
          <li class="fragment">Clean (and good looking) APIs between the abstractions.</li>
          <li class="fragment">Compiler backend that can stitch different abstractions together.</li>
        </ul>
        </font>
      </div>
    </div>
  </section>

  <section class="center">
    <h2>Clean API</h2>
    <ul>
      <li class="fragment">Mixing abstractions in the module granularity seems reasonable.</li>
      <ul>
        <li class="fragment">Clean separation of compilers between abstractions.</li>
        <li class="fragment">IO ports are concrete targets that the HLS compilers can try abstracting away.</li>
      </ul>
  </section>

  <section class="center">
    <h4>How should the HLS APIs look like in this world?</h4>
    <ul>
      <li class="fragment">Want to separate the compute description from the compiler flags (HeteroCL).</li>
      <li class="fragment">Want to specify the HLS compiler flags in a single location.</li>
      <ul>
        <li class="fragment">Easier to specify relationships between flags.</li>
        <li class="fragment">Cleaner code.</li>
      </ul>
      <li class="fragment">Want to abstract out the bus/RTL interface.</li>
      <li class="fragment">Want to pass parameters from the SoC side.</li>
    </ul>
  </section>

  <section class="center">
    <h2>Compiler Backend - Goals</h2>
    <div class="container" style="grid-template-columns: 1.4fr 1.0fr;">
      <div>
        <img src="./figs/latte24/backend-questionmark.svg" style="height: 500px;"/>
      </div>
      <div>
        <font size="6">
        <ul>
          <li class="fragment">High simulation performance (don't lower everying into RTL).</li>
          <li class="fragment">High QoR (need to preserve circuit semantics).</li>
        </ul>
        </font>
      </div>
    </div>
  </section>

  <section class="center">
    <h2>Compiler Backend - RTL Simulation</h2>
    <div class="container" style="grid-template-columns: 1.4fr 1.0fr;">
      <div>
        <img src="./figs/latte24/backend-rtl-sim.png" style="height: 500px;"/>
      </div>
      <div>
        <font size="6">
        <ul>
          <li class="fragment">Instead of lowering higher level abstractions into RTL, emit discrete event models and link them during simulator compile time.</li>
        </ul>
        </font>
      </div>
    </div>
  </section>

  <section class="center">
    <h2>Compiler Backend - RTL Simulation</h2>
    <div class="container" style="grid-template-columns: 1.4fr 1.0fr;">
      <div>
        <img src="./figs/latte24/backend-rtl-sim-details.png" style="height: 500px;"/>
      </div>
      <div>
        <font size="6">
        <ul>
        <li class="fragment">Need to define a common transaction scheme between various abstractions.</li>
        <li class="fragment">The scheduler can make optimizations across all abstractions.</li>
        </ul>
        </font>
      </div>
    </div>
  </section>

  <section class="center">
    <h2>Compiler Backend - FPGA / ASIC</h2>
    <div class="container" style="grid-template-columns: 1.4fr 1.0fr;">
      <div>
        <img src="./figs/latte24/backend-fpga-asic.svg" style="height: 500px;"/>
      </div>
      <div>
        <font size="6">
        <ul>
          <li class="fragment">IRs such as Calyx & "RTL IR" should be able to preserve circuit semantics.</li>
          <li class="fragment">In the short term we can generate Verilog.</li>
          <li class="fragment">In the long term, fix backend tools to directly operate on the "RTL IR".</li>
        </ul>
        </font>
      </div>
    </div>
  </section>

  <section class="center">
    <h2>Compiler Backend - Overall</h2>
    <img src="./figs/latte24/backend-all.png" style="height: 500px;"/>
  </section>
</section>

<!-- -------------------------------------------------------------------- -->

<section>
  <section class="center">
    <h2>Intermediate Representation (IR)</h2>
  </section>

  <section class="center">
    <h2>Incremental First</h2>
    <ul>
      <li class="fragment">As mentioned in the previous section, it is crucial to support <strong>incremental compilation and caching</strong>.</li>
      <ul>
        <li class="fragment">Crucial for quick iteraion and early PPA estimation.</li>
      </ul>
      <li class="fragment">Arguably the most important feature to hardware designers.</li>
      <li class="fragment">If we take the embedded DSL approach, we don't have to redo this ourselves!</li>
      <li class="fragment">E.g., Rust already has 3rd party build cache tools (sccache).</li>
    </ul>
  </section>

  <section class="center">
    <h3>RTL Level IR : Better In Memory Representation</h3>
    <div class="container" style="grid-template-columns: 1.4fr 1.0fr;">
      <div>
        <img src="./figs/latte24/rtl-ir.png" style="height: 500px;" class="fragment"/>
      </div>
      <div>
        <font size="5">
        <ul>
          <li class="fragment">Why does this even matter?</li>
          <li class="fragment">The primitives available in your IR affects QoR.</li>
          <li class="fragment">The in memory representation of the circuit affects compiler performance.</li>
          <ul>
            <li class="fragment">Graph representation can affect graph traversal speed. <a href="https://www.hillelwayne.com/post/graph-types/">The hunt for missing datatypes</a></li>
          </ul>
        </ul>
        </font>
      </div>
    </div>
  </section>

  <section data-auto-animate>
    <h3>SSA Rep. Problem</h3>
    <p>FIRRTL's combinational loop detection pass</p>
    <pre data-id="code-animation"><code class="scala" data-trim data-line-numbers="1-6|23,27,31|8,13,14,15,18,19|42">
    class CheckCombLoops
        extends Transform
        with RegisteredTransform
        with DependencyAPIMigration {

      ...

      private def getStmtDeps(
        simplifiedModules: mutable.Map[String, AbstractConnMap],
        deps:              MutableConnMap
      )(s:                 Statement
      ): Unit = s match {
        case Connect(info, loc, expr) => ...
        case w: DefWire => ...
        case DefNode(info, name, value) =>
          ...
          getExprDeps(deps, lhs, info)(value)
        case m: DefMemory if (m.readLatency == 0) => ...
        case i: WDefInstance => ...
        case _ => s.foreach(getStmtDeps(simplifiedModules, deps))
      }

      private def run(state: CircuitState) = {
        ...
        topoSortedModules.foreach {
          ...
          case m: Module =>
            val portSet = m.ports.map(p => LogicNode(p.name)).toSet
            val internalDeps = new MutableDiGraph[LogicNode] with MutableEdgeData[LogicNode, Info]
            portSet.foreach(internalDeps.addVertex(_))
            m.foreach(getStmtDeps(simplifiedModuleGraphs, internalDeps))

            moduleGraphs(m.name) = internalDeps
            simplifiedModuleGraphs(m.name) = moduleGraphs(m.name).simplify(portSet)
            // Find combinational nodes with self-edges; this is *NOT* the same as length-1 SCCs!
            for (unitLoopNode &lt;- internalDeps.getVertices.filter(v =&gt; internalDeps.getEdges(v).contains(v))) {
              errors.append(new CombLoopException(m.info, m.name, Seq(unitLoopNode.name)))
            }

            for (scc &lt;- internalDeps.findSCCs.filter(_.length &gt; 1)) {
              val sccSubgraph = internalDeps.subgraph(scc.toSet)
              val cycle = findCycleInSCC(sccSubgraph)
              (cycle.zip(cycle.tail)).foreach({ case (a, b) =&gt; require(internalDeps.getEdges(a).contains(b)) })
              // Reverse to make sure LHS comes after RHS, print repeated vertex at start for legibility
              val intuitiveCycle = cycle.reverse
              val repeatedInitial = prettyPrintAbsoluteRef(Seq(m.name), intuitiveCycle.head)
              val expandedCycle = expandInstancePaths(m.name, moduleGraphs, moduleDeps, Seq(m.name), intuitiveCycle)
              errors.append(new CombLoopException(m.info, m.name, repeatedInitial +: expandedCycle))
            }
          case m => throwInternalError(s"Module ${m.name} has unrecognized type")
        }
        ...
      }
    }
    </code></pre>
    <div class="r-stack">
      <p id="special1" style="transition: all .2s ease; opacity: 0; visibility: hidden; will-change: opacity;">We are traversing the statements to build a graph of the nodes.</p>
      <p id="special2" style="transition: all .2s ease; opacity: 0; visibility: hidden; will-change: opacity;">We are traversing the graph once again to check for comb loops.</p>
    </div>
  </section>

  <section class="center">
    <h3>Graph Rep.</h3>
    <font size="6">
    <div class="container" style="grid-template-columns: 1.0fr 1.0fr;">
      <div>
        <ul>
          <li class="fragment">The above pattern of traversing the graph twice is a very common pattern in FIRRTL passes.</li>
          <li class="fragment">If we had a graph representation of the circuit, we wouldn't have had to traverse the circuit twice.</li>
        </ul>
      </div>
      <div>
        <ul>
          <li class="fragment">Compared to a SSA style, "human readable" IR, debugging passes might become more difficult.</li>
        </ul>
      </div>
    </div>
    </font>
  </section>

  <section class="center">
    <h3>Graph Rep. Implementation Details</h3>
    <div class="container" style="grid-template-columns: 1.0fr 1.4fr;">
      <div>
        <img src="./figs/latte24/lgraph.jpg">
      </div>
      <div>
        <font size="5">
        <ul>
          <li class="fragment">lGraph : high perf. graph based IR.</li>
{# <ul> #}
{# <li class="fragment">Hypergraph where each node represents a module and the edges represents the connections.</li> #}
{# <ul> #}
{# <li class="fragment">Submodules forms a graph within a node representing the parent module.</li> #}
{# </ul> #}
{# <li class="fragment">Mmaps disk pages onto virtual memory to reduce memcpy overheads.</li> #}
{# <li class="fragment">Supports graph traversals such that you can access nodes located in adjacent cachelines.</li> #}
{# </ul> #}
        </ul>
        </font>
      </div>
  </section>

{# <section class="center"> #}
{# <h3>Graph Rep. Exploiting Parallelism</h3> #}
{# <ul> #}
{# <li class="fragment">Again, the compiler performance is crucial for HW designers : exploit parallelism.</li> #}
{# <li class="fragment">The passes should be written as if it is working on a single thread.</li> #}
{# <ul> #}
{# <li class="fragment">The complexities of dealing with parallelism should be hidden from the pass-writer.</li> #}
{# </ul> #}
{# <li class="fragment">The interpreter (compiler) must be able to partition the graph and execute passes in parallel.</li> #}
{# </ul> #}
{# </section> #}

{# <section class="center"> #}
{# <h4>FIRRTL In Memory Representation Problem 2</h4> #}
{# <pre data-id="code-animation"><code class="scala" data-trim data-line-numbers> #}
{# case class Mux(...) #}
{# case class UIntLiteral(...) #}
{# case class SIntLiteral(...) #}
{# case class DefWire(...) #}
{# case class DefRegister(...) #}
{# case class DefInstance(...) #}
{# case class DefMemory(...) #}
{# abstract class PrimOp extends FirrtlNode #}
{# </code></pre> #}
{# <ul> #}
{# <li class="fragment">Limited set of primitives &rarr; QoR may be low.</li> #}
{# <li class="fragment">Compiler & backend tools spends a lot of time recreating semantics.</li> #}
{# </ul> #}
{# </section> #}

{# <section class="center"> #}
{# <h4>Possible Primitives</h4> #}
{# <pre data-id="code-animation"><code class="scala" data-trim data-line-numbers="9-14"> #}
{# case class Mux(...) #}
{# case class UIntLiteral(...) #}
{# case class SIntLiteral(...) #}
{# case class DefWire(...) #}
{# case class DefRegister(...) #}
{# case class DefInstance(...) #}
{# case class DefMemory(...) #}
{# abstract class PrimOp extends FirrtlNode #}
{# case class Clock(...) #}
{# case class Reset(...) #}
{# case class OH(...) #}
{# case class PriorityMux(...) #}
{# case class BoolLiteral(...) #}
{# case class DecoupledInterface(...) #}
{# </code></pre> #}
{# <ul> #}
{# <li class="fragment">Add more primitives such that we can preserve more higher level circuit semantics.</li> #}
{# <li class="fragment">Need to find a good balance between pass writing vs QoR.</li> #}
{# </ul> #}
{# </section> #}

  <section class="center">
    <h3>Support for Multiple Abstractions</h3>
    <div class="container" style="grid-template-columns: 1.5fr 1.0fr;">
      <div class="fragment">
        <img src="./figs/latte24/backend-all.png" style="height: 500px;"/>
      </div>
      <div>
        <font size="5">
        <ul>
          <li class="fragment">As we discussed, the IRs have to be able to support multiple abstractions from the frontend.</li>
        </ul>
        </font>
      </div>
    </div>
  </section>
</section>

<!-- -------------------------------------------------------------------- -->

<section>
  <section class="center">
    <h2>Reference</h2>
  </section>
</section>

{% endblock %}
