{% extends "base/base.jinja2" %}

{# HTML title #}
{% set webpage_title = "ATHLETE Quarterly Review (Dec 2023) - TidalSim: Multi-Level Microarchitectural Simulation and Applications in Verification" %}
{# Short description #}
{% set description = "Using ISA + uArch + RTL simulation for high throughput, low latency, high fidelity simulations." %}
{# List of authors #}
{% set author = "Vighnesh Iyer, Raghav Gupta" %}
{# Change ‘venue’ to a conference or workshop name if any #}
{% set venue = "ATHLETE Quarterly Review (Dec 2023)" %}
{# Publication info (hidden by default) #}
{% set pub_datetime_iso = "2023-12-02" %}
{% set pub_date = "December 2, 2023" %}

{# Custom styles and JS for a particular talk #}
{% block custom_head %}
<style>
</style>
{% endblock %}

{% block theme %}
import '/themes/remark-ish.scss'
import 'reveal.js/plugin/highlight/monokai.css'
{% endblock %}

{% block slides %}
<section class="center">
  <h1>TidalSim: Multi-Level Microarchitecture Simulation and Applications in Verification</h1>
  <h2>Vighnesh Iyer, Raghav Gupta, Dhruv Vaish, Bora Nikolic, Sophia Shao</h2>
  <h3>ATHLETE Quarterly Review</h3>
  <h4>Monday, December 4th, 2023</h4>
</section>

<section>
  <section>
    <h2 class="center">Motivation and Background</h2>
  </section>

  <section>
    <h2>Motivation</h2>

    <ul>
      <li class="fragment">We want fast design iteration and evaluation of PPA + verification given real workloads
      <!--Fast design iteration and evaluation of PPA + verification requires stimulus that's representative and comprehensive wrt real workloads (execution fragments)-->
        <ul>
          <li class="fragment"><em>Performance estimation:</em> Impact of μArch optimizations / HW parameters on real workloads</li>
          <li class="fragment"><em>Power macromodeling:</em> Identification of important netlist nodes in power model + traces for training</li>
          <li class="fragment"><em>Verification:</em> Bootstrapping fuzzing loops + coverpoint synthesis</li>
        </ul>
      </li>
      <li class="fragment">The enablers are: <em>fast and accurate μArch simulation</em> and a way to identify <em>unique execution fragments</em>
        <ul>
          <li class="fragment"><em>Performance estimation:</em> Performance metric extraction from fast RTL simulation</li>
          <li class="fragment"><em>Power macromodeling:</em> Extraction of interesting program traces for clustering/training</li>
          <li class="fragment"><em>Verification:</em> Extraction of traces for coverpoint/specification synthesis + state seeding for fuzzing</li>
        </ul>
      </li>
    </ul>
  </section>

  <section>
    <h2>Problem Overview</h2>

    <p class="center fragment">Fast RTL-level μArch simulation and performance metric / interesting trace extraction</p>
    <p class="center fragment"><em><strong>enables</strong></em></p>
    <p class="center fragment">Rapid RTL iteration with performance, power modeling, and verification evaluation on real workloads</p>
    <hr class="fragment">
    <p class="center fragment">How can we achieve high throughput, high fidelity, low latency μArch simulation with RTL-level interesting trace extraction?</p>
  </section>

  <section>
    <h2>Existing μArch Evaluation Strategies</h2>

    <table style="width: 100%; font-size:90%;">
      <thead><tr>
        <th></th>
        <th>Throughput</th>
        <th>Latency</th>
        <th>Fidelity</th>
      </tr></thead>
      <tbody><tr class="fragment">
        <td>ISA Simulation</td>
        <td class="bg-green">10-100+ MIPS</td>
        <td class="bg-green">&lt;1 second</td>
        <td class="bg-red">None</td>
      </tr>
      <tr class="fragment">
        <td>μArch Perf Sim</td>
        <td class="bg-orange">100 KIPS (gem5)</td>
        <td class="bg-green">5-10 seconds</td>
        <td class="bg-orange">5-10% avg IPC error</td>
      </tr>
      <tr class="fragment">
        <td>RTL Simulation</td>
        <td class="bg-red">1-10 KIPS</td>
        <td class="bg-orange">5-10 minutes</td>
        <td class="bg-green">cycle-exact</td>
      </tr>
      <tr class="fragment">
        <td>FireSim (FPGA)</td>
        <td class="bg-green">1-50 MIPS</td>
        <td class="bg-red">2-6 hours</td>
        <td class="bg-green">cycle-exact</td>
      </tr>
      <tr class="fragment">
        <td><strong>TidalSim</strong></td>
        <td>10 MIPS</td>
        <td>&lt;1 minute</td>
        <td style="font-size: 90%">&lt;5% error, 10k intervals</td>
      </tr>
      </tbody>
    </table>

    <ul style="margin-top: 1rem;" class="fragment">
      <li>Combine the strengths of ISA, μArch, and RTL simulators
        <ul><li>Multi-level simulation</li></ul>
      </li>
    </ul>
  </section>

  <section>
    <h2>Phase Behavior of Programs</h2>

    <div class="container">
    <div>
    <ul style="font-size:95%">
      <li class="fragment" data-fragment-index="1">Program execution traces aren’t random
        <ul class="fragment" data-fragment-index="2">
          <li>They execute the same code again-and-again</li>
          <li>Application execution traces can be split into <strong style="text-decoration:underline;">phases</strong> that exhibit similar μArch behavior</li>
        </ul>
      </li>
      <li class="fragment" data-fragment-index="4">Prior work: SimPoint
        <ul class="fragment" data-fragment-index="5">
          <li>Identify basic blocks executed in a given interval (e.g. 1M instruction intervals)</li>
          <li>Embed each interval using their ‘basic block vector’</li>
          <li>Cluster intervals using k-means</li>
        </ul>
      </li>
      <li class="fragment" data-fragment-index="6">Similar intervals → similar μArch behaviors
        <ul class="fragment" data-fragment-index="7"><li>Only execute unique intervals in low-level RTL simulation!</li></ul>
      </li>
    </ul>
    </div>
    <div class="fragment" data-fragment-index="3">
      <img src="./figs/multi-level-sim/simpoint-gzip_phases.gif" />
      <img src="./figs/multi-level-sim/simpoint-gcc_phases.gif" />
    </div>
    </div>
  </section>

  <section>
    <h2>Prior Work</h2>

    <ul>
      <li class="fragment"><em>Sampled</em> simulation techniques have been used in μArch simulators for decades
        <ul>
          <li class="fragment">SimPoint-style sampling (interval clustering, large intervals)</li>
          <li class="fragment">SMARTs-style sampling (reservoir sampling, small intervals)</li>
          <li class="fragment">Implemented in gem5, Sniper, ZSim, SST</li>
        </ul>
      </li>
      <li class="fragment">LiveSim proposed 2-level simulation (ISA → μArch sim) for rapid iteration of μArch parameters
        <ul>
          <li>Functional warmup was used for the cache and branch predictor models</li>
        </ul>
      </li>
    </ul>
  </section>

  <section>
    <h2>What's New</h2>

    <ul>
      <li class="fragment">No prior work on ISA ↔ uArch models ↔ RTL multi-level simulation with functional warmup</li>
      <li class="fragment">No substantial work on binary-agnostic interval embeddings</li>
      <li class="fragment">No one has leveraged the special collateral (waveforms + high-fidelity performance metrics) you can only get from RTL simulation</li>
    </ul>
  </section>

  <section>
    <h2>Overview of Multi-Level Simulation Flow</h2>

    <ul>

    </ul>
  </section>
</section>



<!--
Break this slide into multiple parts
- Multi-Level Microarchitectural Simulation
  - Program intervals
  - Basic block embedding (show example)
  - Clustering (show example of clusters we extracted, 2D SVD projection and cluster coloring)
  - Checkpointing and snapshot taking
  - Injection into RTL-level simulation
  - Performance metric extraction
  - Extrapolation
-->
<section>
  <h2>Multi-Level Simulation Flow</h2>
  <div class="container" style="column-gap:0; grid-template-columns:1.75fr 1fr">
  <div style="display:grid; align-items: center;">
    <img src="./figs/multi-level-sim/multi_level_sim_overview.svg" />
  </div>
  <div style="font-size:80%;">
  <ul>
    <li class="fragment">Execute the application in ISA-level simulation
      <ul class="fragment">
        <li>Use SimPoint style interval clustering</li>
        <li>Capture arch checkpoints for each unique interval</li>
        <li>Capture memory / branch / PC traces for each interval</li>
      </ul>
    </li>
    <li class="fragment">Inject traces into uArch component simulator
      <ul class="fragment">
        <li>Separate model per component (cache, BP)</li>
        <li>Functional warmup</li>
      </ul>
    </li>
    <li class="fragment">Inject uArch state into RTL sim
      <ul class="fragment">
        <li>Detailed warmup</li>
        <li>Performance numbers</li>
      </ul>
    </li>
    <li class="fragment">Extrapolate up the stack</li>
  </ul>
  </div>
  </div>
</section>

<section data-markdown>
  <textarea data-template>
## Infrastructure
- spike <!-- .element: class="fragment" -->
  - Execution fragment extraction + clustering (Simpoint-style based on PC trace / BBV)
  - Checkpointing support and arch+uArch state dumping
- Trace-based cache/BP model (built-in spike cache model + rivet BP model) <!-- .element: class="fragment" -->
  - Functional warmup
  - Ideally: memory timestamp record → cache uArch state reconstruction
- Chipyard SoC VCS/Verilator sim <!-- .element: class="fragment" -->
  - Need arch+uArch state injection and side-channel for perf metric extraction
  - Detailed warmup + perf metrics measurement
  - Intervals are still too long to run in RTL sim → need sampling of each interval
  </textarea>
</section>

<!--
- Early results
  - Show some results for aha-mont64 / embench benchmarks, discuss simulation performance
  - Show IPC error and correlation and error vs cluster distance
-->

<!--
- Functional warmup
  - Show Livesim graphs - detailed warmup isn't sufficient! esp when caches are huge and warmup delays are in 1M insts
  - 
-->

<!-- 
- Applications
  - Performance evaluation and DSE
  - Fuzzing bootstrap
  - Coverpoint synthesis
  - Power modeling
-->

<section data-markdown>
  <textarea data-template>
## Benchmarks + Case Study
- SoC: Base Chipyard SoC with Rocket
  - BOOM is stretch goal
- For pipecleaning
  - Embench, Coremark (baremetal)
  - Linux boot
- For evaluation
  - HyperProtoBench
  - Graph benchmark suite (GAP)
- Case study
  - Evaluate cache sizing between L1d/L1i
  - Investigate balancing of 2-level cache hierarchies
  - Investigate unified vs separate I/D L2 caches
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
## Things That Can Go Wrong
- uArch state injection is much more complicated than expected
  - spike cache model takes too much effort to inject into RTL sim
  - spike BP model doesn’t match RTL
  - latent state in fesvr can’t be ported to RTL sim
- Basic block clustering produces too many or too long execution fragments
  - Need to perform additional sampling which can introduce too much error
- Chipyard parameter space can’t be mapped onto spike parameter space
- The multi-level simulator has too narrow a scope
  - We only focus on cache warmup
  - Need a story for other long-lived uArch blocks
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
## Checkpoints
- By mid-October
  - Spike cache model state dumping
  - Inject arch state in RTL sim
- By end-October
  - Clustering binary with spike-as-library
  - Inject uArch state in RTL sim
- By mid-November
  - Improve clustering binary, parallel simulations
  - Get perf metrics from RTL sim side-channel
- By end-November
  - Performance opt + compare errors vs pure RTL sim
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
## Expected Results
- Run embench binaries and get numbers on new RTL within minutes
  - Performance estimates should be close to pure RTL sim (at least &lt;10% IPC error, but we can probably do much better)
- Prior work
  - Sampled simulation: SimPoint / SMARTs
  - 2-Level simulation: LiveSim (HPCA 16, Renau)
  </textarea>
</section>
{% endblock %}
