<section class="center">
  <h2 class="center">1. Why: What Is the Problem?</h2>
  <ul>
    <li class="fragment">Emergence of domain-specialized heterogeneous SoCs</li>
    <li class="fragment">Rapid design iteration is the key to achiving optimal PPA + time to market</li>
    <li class="fragment">Existing pre-silicon evaluation (power, performance, functionality) techniques on real workloads are unsuitable for rapid iteration</li>
  </ul>
</section>

<section>
  <h2>The End of "Free" Technology Scaling</h2>

  <p class="center fragment"><strong>Moore's Law</strong>: transistor counts double while cost/transistor halves every 2 years</p>

  <div class="container fragment">
    <div>
      <img width="60%" src="./figs/quals/wafer_cost_trend.jpg" />
    </div>
    <div>
      <img width="60%" src="./figs/quals/per_transistor_cost_trend.png" />
    </div>
  </div>

  <ul class="small">
    <li class="fragment">Per-wafer and per-transistor costs continue to grow with process scaling<sup>[1, 2]</sup> unless heavily amortized</li>
  </ul>

  <p class="fragment center">{{ rightarrow }} Transistors are no longer free</p>

  <div class="fragment">
  <hr>
  <div class="verysmall">
    <p class="footnote">
    [1]: {% include "figs/quals/wafer_cost_trend.jinja2" %}.<br/>
    [2]: {% include "figs/quals/per_transistor_cost_trend.jinja2" %}.
    </p>
  </div>
  </div>
</section>

<section>
  <h2>Stagnation of Single Thread Performance</h2>

  <p class="center fragment"><strong>Dennard Scaling</strong>: power density is constant with technology scaling</p>

  <div class="container fragment">
    <div>
      <img width="80%" src="./figs/quals/single_thread_performance_trend.png" />
    </div>
    <div>
      <img width="100%" src="./figs/quals/50_years_of_microprocessor_trend_data.png" />
    </div>
  </div>

  <ul class="small">
    <li class="fragment">General-purpose single-thread performance has stagnated<sup>[1,2]</sup></li>
  </ul>

  <p class="fragment center">{{ rightarrow }} Can't rely on technology scaling for gains in performance</p>

  <div class="fragment">
  <hr>
  <div class="verysmall">
    <p class="footnote">
    [1]: {% include "figs/quals/single_thread_performance_trend.jinja2" %}.<br/>
    [2]: {% include "figs/quals/50_years_of_microprocessor_trend_data.jinja2" %}.
    </p>
  </div>
  </div>
</section>

<section>
  <h2>The Consequences of These Trends</h2>

  <div class="container">
    <div class="fragment">
      <p>End of Moore's Law</p>
      <p>{{ rightarrow }} $/transistor not falling</p>
      <p>{{ rightarrow }} Transistors are no longer free</p>
    </div>
    <div class="fragment">
      <p>End of Dennard Scaling</p>
      <p>{{ rightarrow }} Power density <em>increasing</em></p>
      <p>{{ rightarrow }} <em>GPP</em> performance stagnating</p>
    </div>
  </div>

  <p class="center"></p>

<em>General-purpose</em> single thread performance is stagnating, but tuned cores still can squeeze a lot more out
</section>
 
<section>
  <h2>The New-Era of Domain-Specialized Heterogeneous SoCs</h2>
  
  <p class="center fragment">Motivates two types of specialization</p>

  <ul>
    <li>Heterogeneous cores including core-coupled accelerators (ISA extensions)</li>
    <li>Core-external accelerators</li>
  </ul>
</section>

<section>
  <h2>Design Challenges</h2>

Note the cost figure
What is the challenge? pick specializations that are possible and evaluate them
Optimizing real-world software pre-silicon is very hard
</section>

<section>
  <h2>Pre-Silicon Evaluation</h2>

  Enumerate all the techniques in abbreviated table

  <h2>Existing μArch Evaluation Strategies</h2>

  <table style="width: 100%; font-size:90%;">
    <thead><tr>
      <th></th>
      <th>Throughput</th>
      <th>Latency</th>
      <th>Fidelity</th>
    </tr></thead>
    <tbody><tr class="fragment">
      <td>ISA Simulation</td>
      <td class="bg-green">10-100+ MIPS</td>
      <td class="bg-green">&lt;1 second</td>
      <td class="bg-red">None</td>
    </tr>
    <tr class="fragment">
      <td>μArch Perf Sim</td>
      <td class="bg-orange">100 KIPS (gem5)</td>
      <td class="bg-green">5-10 seconds</td>
      <td class="bg-orange">5-10% avg IPC error</td>
    </tr>
    <tr class="fragment">
      <td>RTL Simulation</td>
      <td class="bg-red">1-10 KIPS</td>
      <td class="bg-orange">5-10 minutes</td>
      <td class="bg-green">cycle-exact</td>
    </tr>
    <tr class="fragment">
      <td>FireSim (FPGA)</td>
      <td class="bg-green">1-50 MIPS</td>
      <td class="bg-red">2-6 hours</td>
      <td class="bg-green">cycle-exact</td>
    </tr>
    <tr class="fragment">
      <td><strong>TidalSim</strong></td>
      <td>10 MIPS</td>
      <td>&lt;1 minute</td>
      <td style="font-size: 90%">&lt;5% error, 10k intervals</td>
    </tr>
    </tbody>
  </table>

  <ul style="margin-top: 1rem;" class="fragment">
    <li>Combine the strengths of ISA, μArch, and RTL simulators
      <ul><li>Multi-level simulation</li></ul>
    </li>
  </ul>

</section>

<section data-visibility="hidden">
  <h2>Motivation</h2>

  <ul>
    <li class="fragment">We want fast design iteration and evaluation of PPA + verification given real workloads
    <!--Fast design iteration and evaluation of PPA + verification requires stimulus that's representative and comprehensive wrt real workloads (execution fragments)-->
      <ul>
        <li class="fragment"><em>Performance estimation:</em> Impact of μArch optimizations / HW parameters on real workloads</li>
        <li class="fragment"><em>Power macromodeling:</em> Identification of important netlist nodes in power model + traces for training</li>
        <li class="fragment"><em>Verification:</em> Bootstrapping fuzzing loops + coverpoint synthesis</li>
      </ul>
    </li>
    <li class="fragment">The enablers are: <em>fast and accurate μArch simulation</em> and a way to identify <em>unique execution fragments</em>
      <ul>
        <li class="fragment"><em>Performance estimation:</em> Performance metric extraction from fast RTL simulation</li>
        <li class="fragment"><em>Power macromodeling:</em> Extraction of interesting program traces for clustering/training</li>
        <li class="fragment"><em>Verification:</em> Extraction of traces for coverpoint/specification synthesis + state seeding for fuzzing</li>
      </ul>
    </li>
  </ul>
</section>
