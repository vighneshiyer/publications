<section>
  <section class="center">
    <h2>5. How (pt 2): TidalSim v2</h2>

    <p class="center fragment">The proposal is structured as 4 main novel extensions to TidalSim v1 that address its limitations in fundamental ways.</p>

    <ol style="list-style-type:lower-alpha;">
      <li class="fragment">Hardcoded sampling methodology prevents exploration of the accuracy/throughput tradeoff space
        <ul class="small">
          <li>{{ rightarrow }} generalizing the spectrum of streaming sampled RTL simulation</li>
          <li>{{ rightarrow }} generalizing representative sampling for PC/binary-agnostic interval embeddings to enable running multi-process workloads in an OS</li>
        </ul>
      </li>
      <li class="fragment">Unvalidated functional warmup models
        <ul class="small">
          <li>{{ rightarrow }} leverage verification libraries and fuzzing to automatically discover mismatches between the warmup model and RTL</li>
        </ul>
      </li>
      <li class="fragment">Inaccurate modeling of time-driven events (e.g. timer interrupts)
        <ul class="small">
          <li>{{ rightarrow }} dynamically moving between arch and RTL simulation to estimate time</li>
        </ul>
      </li>
      <li class="fragment">Only works with processor cores and not heterogeneous IP
        <ul class="small">
          <li>{{ rightarrow }} extend sampled simulation to accelerators</li>
        </ul>
      </li>
    </ol>

    <!-- The limitations that still exist:
    - can't work with an OS (due to virtual PCs from instruction trace conflicting with multiple processes and having incorrect basic block embeddings)
    - can't model timing accurately including timer interrupts and mtime/mcycle values
    - no functional warmup for advanced and virtual memory components (prefetcher, iTLB, dTLB, LLC)
    -->

    <!-- <ol>
      <li>Inaccurate at modeling asynchronous / timing-aware events (timer/external interrupts)</li>
      <li>Hardcoded for a single RTL design point</li>
      <li>Functional warmup models aren't validated against RTL</li>
      <li>Not warming up all necessary uarch state + resolving ambiguity in restoring arch state</li>
      <li>Interval embeddings are binary-aware (not portable) and not microarchitecture-aware (higher liklihood for errors)</li>
      <li>Modeling of I/O (off-chip communication, polling, interrupts) will be inaccurate due to uniform treatment of any memory access</li>
      <li>Interaction with core-coupled accelerators isn't properly embedded or checkpointable</li>
    </ol>-->
  </section>
</section>

<section>
  <section class="center">
    <h2>5.a: Generalizing the Spectrum of Sampled Simulation</h2>
    <!-- generalization + streaming (no preprocessing step required)
      <li>Not general or streaming
        <ul>
          <li>Hardcoded Simpoint-style sampled simulation</li>
          <li>Requires multiple passes over the commit trace / multiple runs of spike</li>
        </ul>
      </li>
    -->
  </section>

    <!-- - We have implemented one specific simulator design point, but now we will generalize it
    - We will devise a parameterized simulator that can implement SMARTs, Simpoint, and hybrid-embedding/sampling approaches to simulation
    - Our formalization will
        - Produce output metrics such as cost, runtime, throughput, latency, time granularity, error bounds
        - In terms of variables such as number of dynamic instructions, number of cores, RTL sim throughput, and of course the simulation methodology
      -->

  <section>
    <h2>Sampled Simulation Techniques</h2>

    <div class="center fragment">
      <img width="70%" src="./figs/dynamic/tidalsim/simulation_techniques.svg" />
    </div>

    <p class="center fragment">Simulation techniques encompass SMARTS, SimPoint, hybrid variants, eager parallel RTL simulation, and many more</p>
  </section>

  <section>
    <h2>A Formalization and Simulation Model</h2>

    <div class="center fragment">
      <img width="40%" src="./figs/dynamic/tidalsim/simulation_techniques.svg" />
    </div>

    <ol class="small">
      <li class="fragment">Only considering techniques that can operate in a streaming fashion, develop a parameterized version of TidalSim
        <ul>
          <li>Streaming necessitates new incremental unsupervised learning algorithms</li>
        </ul>
      </li>
      <li class="fragment">Formalize the interfaces between arch sim, uArch models, and RTL sim</li>
      <li class="fragment">Formalize and parameterize simulation methodology to encompass all prior techniques
        <ul>
          <li>Consider <strong>input parameters</strong> such as interval length ($N$), number of host cores ($n_{cores}$), RTL simulation throughput ($T_{rtl}$), sampling technique ($i \rightarrow \{0, 1\}$)</li>
          <li>Produce estimated <strong>output metrics</strong> such as cost, runtime, aggregate throughput, latency, time-granularity of output, error bounds</li>
        </ul>
      </li>
    </ol>
  </section>

  <section>
    <h2>PC/Binary-Agnostic Embeddings</h2>
          <!-- <li>{{ rightarrow }} generalizing representative sampling for PC/binary-agnostic interval embeddings to enable running multi-process workloads in an OS</li>-->

    <ul>
      <li></li>
    </ul>
  </section>
</section>

<!-- <section>
  <h2>2. Modeling Timing-Aware Events (Dynamic Simulation)</h2>
  going from one-direction simulation to dynamically changing simulators up and down the stack during execution
</section>

<section>
  <h2>3. Leveraging Chisel for State Injection</h2>
</section>

<section>
  <h2>4. Validating Functional Warmup Models</h2>
</section>

<section>
  <h2>5. Long-Lived uArch State Identification</h2>
</section>

<section>
  <h2>5. Resolving Ambiguity in Forcing Arch State</h2>
</section>

<section>
  <h2>6. Better Interval Embeddings</h2>
</section>

<section>
  <h2>7. Modeling I/O</h2>
</section>

<section>
  <h2>8. Sampled Simulation with Accelerators</h2>
</section>
-->
