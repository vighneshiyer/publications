<section>
  <section class="center">
    <h2>5. How (pt 2): TidalSim v2</h2>

    <p class="center fragment">The proposal is structured as 4 main novel extensions to TidalSim v1 that address its limitations in fundamental ways.</p>

    <ol style="list-style-type:lower-alpha;">
      <li class="fragment">Hardcoded sampling methodology prevents exploration of the accuracy/throughput tradeoff space
        <ul class="small">
          <li>{{ rightarrow }} generalizing the spectrum of streaming sampled RTL simulation</li>
          <li>{{ rightarrow }} generalizing representative sampling for PC/binary-agnostic interval embeddings to enable running multi-process workloads in an OS</li>
        </ul>
      </li>
      <li class="fragment">Unvalidated functional warmup models
        <ul class="small">
          <li>{{ rightarrow }} leverage verification libraries and fuzzing to automatically discover mismatches between the warmup model and RTL</li>
        </ul>
      </li>
      <li class="fragment">Inaccurate modeling of time-driven events (e.g. timer interrupts)
        <ul class="small">
          <li>{{ rightarrow }} dynamically moving between arch and RTL simulation to estimate time</li>
        </ul>
      </li>
      <li class="fragment">Only works with processor cores and not heterogeneous IP
        <ul class="small">
          <li>{{ rightarrow }} extend sampled simulation to accelerators</li>
        </ul>
      </li>
    </ol>

    <!-- The limitations that still exist:
    - can't work with an OS (due to virtual PCs from instruction trace conflicting with multiple processes and having incorrect basic block embeddings)
    - can't model timing accurately including timer interrupts and mtime/mcycle values
    - no functional warmup for advanced and virtual memory components (prefetcher, iTLB, dTLB, LLC)
    -->

    <!-- <ol>
      <li>Inaccurate at modeling asynchronous / timing-aware events (timer/external interrupts)</li>
      <li>Hardcoded for a single RTL design point</li>
      <li>Functional warmup models aren't validated against RTL</li>
      <li>Not warming up all necessary uarch state + resolving ambiguity in restoring arch state</li>
      <li>Interval embeddings are binary-aware (not portable) and not microarchitecture-aware (higher liklihood for errors)</li>
      <li>Modeling of I/O (off-chip communication, polling, interrupts) will be inaccurate due to uniform treatment of any memory access</li>
      <li>Interaction with core-coupled accelerators isn't properly embedded or checkpointable</li>
    </ol>-->
  </section>
</section>

<section>
  <section class="center">
    <h2>5.a: Generalizing the Spectrum of Sampled Simulation</h2>
    <!-- generalization + streaming (no preprocessing step required)
      <li>Not general or streaming
        <ul>
          <li>Hardcoded Simpoint-style sampled simulation</li>
          <li>Requires multiple passes over the commit trace / multiple runs of spike</li>
        </ul>
      </li>
    -->
  </section>

    <!-- - We have implemented one specific simulator design point, but now we will generalize it
    - We will devise a parameterized simulator that can implement SMARTs, Simpoint, and hybrid-embedding/sampling approaches to simulation
    - Our formalization will
        - Produce output metrics such as cost, runtime, throughput, latency, time granularity, error bounds
        - In terms of variables such as number of dynamic instructions, number of cores, RTL sim throughput, and of course the simulation methodology
      -->

  <section>
    <h2>Sampled Simulation Techniques</h2>

    <div class="center fragment">
      <img width="70%" src="./figs/dynamic/tidalsim/simulation_techniques.svg" />
    </div>

    <p class="center fragment">Simulation techniques encompass SMARTS, SimPoint, hybrid variants, eager parallel RTL simulation, and many more</p>
  </section>

  <section>
    <h2>A Formalization and Simulation Model</h2>

    <div class="center fragment">
      <img width="40%" src="./figs/dynamic/tidalsim/simulation_techniques.svg" />
    </div>

    <ol class="small">
      <li class="fragment">Only considering techniques that can operate in a streaming fashion, develop a parameterized version of TidalSim
        <ul>
          <li>Streaming necessitates new incremental unsupervised learning algorithms</li>
        </ul>
      </li>
      <li class="fragment">Formalize the interfaces between arch sim, uArch models, and RTL sim</li>
      <li class="fragment">Formalize and parameterize simulation methodology to encompass all prior techniques
        <ul>
          <li>Consider <strong>input parameters</strong> such as interval length ($N$), number of host cores ($n_{cores}$), RTL simulation throughput ($T_{rtl}$), sampling technique ($i \rightarrow \{0, 1\}$)</li>
          <li>Produce estimated <strong>output metrics</strong> such as cost, runtime, aggregate throughput, latency, time-granularity of output, error bounds</li>
        </ul>
      </li>
    </ol>
  </section>

  <section>
    <h2>PC/Binary-Agnostic Embeddings</h2>
    <!-- <li>{{ rightarrow }} generalizing representative sampling for PC/binary-agnostic interval embeddings to enable running multi-process workloads in an OS</li>-->

    <ul>
      <li class="fragment">Basic block embedding assumes
        <ul>
          <li>There is a static PC {{ rightarrow }} basic block mapping</li>
          <li>Intervals with similar basic block traversals have similar uArch behavior</li>
        </ul>
      </li>
      <li class="fragment">Our embeddings should be PC/binary-agnostic to support portability and multi-process workloads in an OS
        <ul>
          <li>Most prior work only runs single-process workloads using syscall proxies</li>
          <li>Real workloads are heavily affected by interactions between the OS and userspace processes</li>
        </ul>
      </li>
      <li class="fragment">We will explore embeddings with features such as
        <ul>
          <li>Instruction mix, function call frequency, instruction dependencies</li>
          <li>Microarchitectural behaviors: I/D cache misses, BP model mispredicts, TLB behavior</li>
        </ul>
      </li>
    </ul>
  </section>
</section>

<section>
  <section class="center">
    <h2>5.b: Validating Functional Warmup Models</h2>
  </section>

  <section>
    <h2>Validation Flow</h2>
    <p class="center fragment">Functional warmup models need to be validated against the behavior of their modeled RTL</p>

    <div class="center fragment">
      <img src="./figs/dynamic/tidalsim/validation_flow.svg" />
      <figcaption class="small">The flow for validating RTL against its functional warmup model (specifically an L1 cache) using SimCommand, parametric generators, and fuzzing.</figcaption>
    </div>
  </section>

  <section>
    <h2>SimCommand: A Fast RTL Simulation API</h2>
    <ul>
      <li class="fragment">Testbench API embedded in Scala<sup>[1]</sup></li>
      <li class="fragment">Uses chiseltest as the simulator interface</li>
      <li class="fragment">Functional: testbench description and interpretation are split</li>
    </ul>

    <pre class="fragment"><code class="language-scala" data-trim data-noescape>
def enqueue(data: T): Command[Unit] = for {
    _ &lt;- poke(io.bits, data)
    _ &lt;- poke(io.valid, true.B)
    _ &lt;- waitUntil(io.ready, true.B)
    _ &lt;- step(1)
    _ &lt;- poke(io.valid, false.B)
} yield ()
    </pre></code>

    <ul class="smallish">
      <li class="fragment">20x faster than cocotb and chiseltest, parity with SystemVerilog + VCS</li>
      <li class="fragment">Enables writing performant testbenches with fork/join constructs in Scala</li>
    </ul>

    <div class="fragment">
    <hr>
    <div class="verysmall">
      <p class="footnote">
      [1]: Iyer, Vighnesh, et. al., SimCommand: A High Performance Multi-Threaded RTL Testbench API, OSCAR Workshop 2022
      </p>
    </div>
    </div>
  </section>

  <section>
    <h2>Parametric Random Stimulus Generators</h2>
  </section>

  <section>
    <h2>Coverage Feedback</h2>
  </section>

  <section>
    <h2>Parametric Fuzzing</h2>
  </section>
</section>

<section>
  <section>
    <h2>5.c: Putting the 'Tidal' in TidalSim</h2>
  </section>

  <section>
    <h2>Issues with Time Modeling in Sampled Simulation</h2>

    Insert image of timer interrupts being desynced from RTL
  </section>

  <section>
    <h2>TidalSim to Model Time Accurately</h2>

    Insert image of bouncing between simulators and using interval embeddings to estimate actual time advancement
  </section>
</section>

<section>
  <section>
    <h2>5.d: Sampled Simulation with Accelerators</h2>
  </section>

  <section>
    <h2>What Makes Accelerators Suitable?</h2>

    Talk about how accelerator arch state is explicit and accelerators often don't have long-lived uarch state (that requires functional warmup)
  </section>

  <section>
    <h2>Extending Interval Embeddings to Accelerators</h2>

    Need to incorporate accelerator state and the semantics of accelerator ISA instructions to the embedding.
    Consider case of Gemmini - intervals are similar if they execute similar gemmini instructions under same gemmini configuration. can use number of bytes mvin-ed / mvout-ed from sp/acc as a feature.
    Feature tuning needs to be precise here.
  </section>
</section>

<!-- <section>
  <h2>2. Modeling Timing-Aware Events (Dynamic Simulation)</h2>
  going from one-direction simulation to dynamically changing simulators up and down the stack during execution
</section>

<section>
  <h2>3. Leveraging Chisel for State Injection</h2>
</section>

<section>
  <h2>4. Validating Functional Warmup Models</h2>
</section>

<section>
  <h2>5. Long-Lived uArch State Identification</h2>
</section>

<section>
  <h2>5. Resolving Ambiguity in Forcing Arch State</h2>
</section>

<section>
  <h2>6. Better Interval Embeddings</h2>
</section>

<section>
  <h2>7. Modeling I/O</h2>
</section>

<section>
  <h2>8. Sampled Simulation with Accelerators</h2>
</section>
-->
