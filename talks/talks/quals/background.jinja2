<section class="center">
  <h2 class="center">3. Background and Prior Work</h2>
  <ul>
    <li class="fragment">An overview of simulation broadly</li>
    <li class="fragment">Existing microarchitectural simulators</li>
    <li class="fragment">Sampled simulation techniques
      <ul>
        <li>Phase behavior of programs</li>
        <li>SimPoint: Interval embedding and clustering</li>
        <li>SMARTs: Reservoir sampling and bounding sampling errors</li>
        <li>Functional warmup techniques</li>
        <li>Detailed warmup</li>
      </ul>
    </li>
    <li class="fragment">Prior work on rapid microarchitectural evaluation</li>
  </ul>
</section>

<section>
  <h2>A Broad View of Simulation</h2>

  <div class="center">
    <img src="./figs/dynamic/tidalsim/simulators_broadly.svg" />
    <figcaption class="small center">A high-level, generic view of the input and outputs of a simulator.</figcaption>
  </div>

  <ul style="margin-top: 1rem;">
    <li class="fragment">Simulation is the workhorse of architecture evaluation</li>
    <li class="fragment">Simulation inputs can have wide variation of fidelity
      <ul>
        <li><strong>Hardware spec</strong>: high-level models to detailed microarchitecture</li>
        <li><strong>Workload</strong>: high-level algorithmic description to concrete binary</li>
      </ul>
    </li>
    <li class="fragment">The fidelity of simulation outputs tracks that of the inputs</li>
    <!--<li>Inputs: architecture specification or framework, workload
      <ul>
        <li>Specification can be high-level (blocks + instruction spec + latencies) or very detailed</li>
        <li>Workload can be high-level (memory access pattern) or fully concrete</li>
      </ul>
    </li>
    <li>Outputs: execution trace/metrics - how does the architecture execute the workload? - notion of time granularity and space granularity + PPA stuff if available </li>-->
  </ul>

</section>

<section>
  <h2>Hardware Abstractions</h2>

  <p class="center">There are roughly 3 levels of hardware abstractions used for architecture evaluation</p>

  <ol>
    <li>Architectural models with approximate state and timing information</li>
    <li>Microarchitectural models with more refined state and timing</li>
    <li>Register-transfer level (RTL) models with full fidelity state and timing</li>
  </ol>

</section>

<section>
  <h2>Hardware Abstractions: Arch Models</h2>

  Wattch, CACTI, McPAT
  Workload type - high-level or ISA-level
</section>

<section>
  <h2>Hardware Abstractions: uArch Models</h2>
  Workload type - concrete binary
</section>

<section>
  <h2>Hardware Abstractions: RTL</h2>
  Workload type - concrete binary

  <!--RTL vs detailed uArch vs arch vs high-level spec

  We will restrict our scope to architectures which already have concrete implementations.
  No need to high-level analytical analysis since we're trying to speed up iteration loop, not discover new accelerator or core architectures.
  This is a separate research direction.-->
</section>

<section>
  <h2>Simulator Metrics</h2>

  Throughput, accuracy, ... see from paper
</section>

<section>
  <h2>Existing μArch Evaluation Strategies</h2>

  <table style="width: 100%; font-size:90%;">
    <thead><tr>
      <th></th>
      <th>Throughput</th>
      <th>Latency</th>
      <th>Fidelity</th>
    </tr></thead>
    <tbody><tr class="fragment">
      <td>ISA Simulation</td>
      <td class="bg-green">10-100+ MIPS</td>
      <td class="bg-green">&lt;1 second</td>
      <td class="bg-red">None</td>
    </tr>
    <tr class="fragment">
      <td>μArch Perf Sim</td>
      <td class="bg-orange">100 KIPS (gem5)</td>
      <td class="bg-green">5-10 seconds</td>
      <td class="bg-orange">5-10% avg IPC error</td>
    </tr>
    <tr class="fragment">
      <td>RTL Simulation</td>
      <td class="bg-red">1-10 KIPS</td>
      <td class="bg-orange">5-10 minutes</td>
      <td class="bg-green">cycle-exact</td>
    </tr>
    <tr class="fragment">
      <td>FireSim (FPGA)</td>
      <td class="bg-green">1-50 MIPS</td>
      <td class="bg-red">2-6 hours</td>
      <td class="bg-green">cycle-exact</td>
    </tr>
    <tr class="fragment">
      <td><strong>TidalSim</strong></td>
      <td>10 MIPS</td>
      <td>&lt;1 minute</td>
      <td style="font-size: 90%">&lt;5% error, 10k intervals</td>
    </tr>
    </tbody>
  </table>

  <ul style="margin-top: 1rem;" class="fragment">
    <li>Combine the strengths of ISA, μArch, and RTL simulators
      <ul><li>Multi-level simulation</li></ul>
    </li>
  </ul>
</section>

<section>
  <h2>Phase Behavior of Programs</h2>

  <div class="container">
  <div>
  <ul style="font-size:95%">
    <li class="fragment" data-fragment-index="1">Program execution traces aren’t random
      <ul class="fragment" data-fragment-index="2">
        <li>They execute the same code again-and-again</li>
        <li>Application execution traces can be split into <strong style="text-decoration:underline;">phases</strong> that exhibit similar μArch behavior</li>
      </ul>
    </li>
    <li class="fragment" data-fragment-index="4">Prior work: SimPoint
      <ul class="fragment" data-fragment-index="5">
        <li>Identify basic blocks executed in a given interval (e.g. 1M instruction intervals)</li>
        <li>Embed each interval using their ‘basic block vector’</li>
        <li>Cluster intervals using k-means</li>
      </ul>
    </li>
    <li class="fragment" data-fragment-index="6">Similar intervals → similar μArch behaviors
      <ul class="fragment" data-fragment-index="7"><li>Only execute unique intervals in low-level RTL simulation!</li></ul>
    </li>
  </ul>
  </div>
  <div class="fragment" data-fragment-index="3" style="display:grid; align-content: center; justify-items:center;">
    <img src="./figs/multi-level-sim/simpoint-gzip_phases.gif" />
    <img src="./figs/multi-level-sim/simpoint-gcc_phases.gif" />
  </div>
  </div>
</section>

<section>
  <h2>Prior Work</h2>

  <ul>
    <li class="fragment"><em>Sampled</em> simulation techniques have been used in μArch simulators for decades
      <ul>
        <li class="fragment">SimPoint-style sampling (interval clustering, large intervals)</li>
        <li class="fragment">SMARTs-style sampling (reservoir sampling, small intervals)</li>
        <li class="fragment">Implemented in gem5, Sniper, ZSim, SST</li>
      </ul>
    </li>
    <li class="fragment">LiveSim proposed 2-level simulation (ISA → μArch sim) for rapid iteration of μArch parameters
      <ul>
        <li>Functional warmup was used for the cache and branch predictor models</li>
      </ul>
    </li>
  </ul>
</section>
