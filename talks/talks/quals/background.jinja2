<section class="center">
  <h2 class="center">3. Background and Prior Work</h2>
  <ul>
    <li class="fragment">An overview of simulation broadly
      <ul><li>Abstractions used in hardware modeling</li></ul>
    </li>
    <li class="fragment">The limitations of existing microarchitectural simulators</li>
    <li class="fragment">Sampled simulation techniques
      <ul>
        <li>Phase behavior of programs</li>
        <li>SimPoint: Interval embedding and clustering</li>
        <li>SMARTs: Reservoir sampling and bounding sampling errors</li>
        <li>Functional warmup techniques</li>
        <li>Detailed warmup</li>
      </ul>
    </li>
    <li class="fragment">Prior work on rapid microarchitectural evaluation</li>
  </ul>
</section>

<section>
  <h2>A Broad View of Simulation</h2>

  <div class="center">
    <img src="./figs/dynamic/tidalsim/simulators_broadly.svg" />
    <figcaption class="small center">A high-level, generic view of the input and outputs of a simulator.</figcaption>
  </div>

  <ul style="margin-top: 1rem;">
    <li class="fragment">Simulation is the workhorse of architecture evaluation</li>
    <li class="fragment">Simulation inputs can have wide variation of fidelity
      <ul>
        <li><strong>Hardware spec</strong>: high-level models to detailed microarchitecture</li>
        <li><strong>Workload</strong>: high-level algorithmic description to concrete binary</li>
      </ul>
    </li>
    <li class="fragment">The fidelity of simulation outputs tracks that of the inputs</li>
    <!--<li>Inputs: architecture specification or framework, workload
      <ul>
        <li>Specification can be high-level (blocks + instruction spec + latencies) or very detailed</li>
        <li>Workload can be high-level (memory access pattern) or fully concrete</li>
      </ul>
    </li>
    <li>Outputs: execution trace/metrics - how does the architecture execute the workload? - notion of time granularity and space granularity + PPA stuff if available </li>-->
  </ul>
</section>

<section>
  <h2>Hardware Abstractions</h2>

  <p class="center fragment">There are roughly <strong>4 levels of hardware abstractions</strong> used in architecture evaluation</p>

  <ol>
    <li class="fragment">Architectural (functional) models</li>
    <li class="fragment">Microarchitectural models (<em>"rough"</em>) with approximate state and timing</li>
    <li class="fragment">Microarchitectural models (<em>"detailed"</em>) with more refined state and timing</li>
    <li class="fragment">Register-transfer level (RTL) models with full fidelity state and timing</li>
  </ol>
</section>

<section>
  <h2>Hardware Abstractions: Architectural (Functional) Models</h2>

  <p class="fragment center">Functional simulators emulate an architecture and can execute workloads (e.g. ELF binaries).</p>
  <p class="fragment center">They only model <em>architectural</em> state, defined in an ISA specification. No <em>microarchitectural</em> state is modeled.</p>

  <ul>
    <li class="fragment">Examples
      <ul>
        <li>RISC-V: <a href="https://github.com/riscv-software-src/riscv-isa-sim">spike</a>, <a href="https://github.com/chipsalliance/dromajo">dromajo</a>, <a href="https://www.imperas.com/riscvovpsim-free-imperas-risc-v-instruction-set-simulator">Imperas riscvOVPSim</a></li>
        <li>Multi-ISA (x86, ARM, RISC-V): <a href="https://www.qemu.org/">qemu</a></li>
      </ul>
    </li>
    <li class="fragment">Very fast (10-1000 MIPS), low startup latency (instant)</li>
    <li class="fragment">Cannot estimate PPA</li>
  </ul>
</section>

<section>
  <h2>Hardware Abstractions: "Rough" uArch Models - Micro-Kernel Accelerators</h2>

  <ul class="smallish">
    <li class="fragment">Microarchitecture is modeled with high-level blocks with a dataflow and timing relationship</li>
    <li class="fragment">Prior Work: Aladdin<sup>[1]</sup> is a microarchitecture estimation and simulation tool for analyzing the PPA of potential accelertors for kernels written in C</li>
  </ul>

  <div class="center r-stack">
    <div class="fragment fade-in-then-out" style="display: grid; place-items: center;">
      <img width="50%" src="./figs/quals/aladdin_architecture.png">
      <figcaption class="small center">System architecture assumed by Aladdin</figcaption>
    </div>
    <div class="fragment fade-in" style="display: grid; place-items: center;">
      <img width="70%" src="./figs/quals/aladdin_flow.png">
      <figcaption class="small center">Aladdin flow. Inputs: workload. Outputs: dataflow microarchitecture + PPA</figcaption>
    </div>
    <!--<div class="fragment fade-in" style="display: grid; place-items: center;">
      <img width="20%" src="./figs/quals/aladdin_simulation.png">
      <figcaption class="small center">Aladdin simulation</figcaption>
    </div>-->
  </div>

  <div class="fragment">
  <hr>
  <div class="verysmall">
    <p class="footnote">
    [1]: Shao, Y.S., Reagen, B., Wei, G.Y. and Brooks, D., 2014. Aladdin: A pre-rtl, power-performance accelerator simulator enabling large design space exploration of customized architectures. ACM SIGARCH.
    </p>
  </div>
  </div>
</section>

<section>
  <h2>Hardware Abstractions: "Rough" uArch Models - ML Accelerators</h2>

  <ul class="small">
    <li class="fragment">Rough uArch models are used for evaluating ML accelerator architectures, dataflows, and workload mappings</li>
    <li class="fragment">Prior Work: Timeloop<sup>[1]</sup>, Accelergy<sup>[2]</sup> provides a framework for describing accelerator microarchitecture with parameterizable blocks (PEs, scratchpads), workload mappings, and simulating workloads for PPA estimates</li>
  </ul>

  <div class="center r-stack">
    <div class="fragment fade-in-then-out" style="display: grid; place-items: center;">
      <img width="50%" src="./figs/quals/accelergy_example_arch.png" style="margin:0;">
      <figcaption class="small center">An example microarchitecture modeled by Timeloop</figcaption>
    </div>
    <div class="fragment fade-in-then-out" style="display: grid; place-items: center;">
      <img width="50%" src="./figs/quals/timeloop_arch_definition.png" style="margin:0;">
      <figcaption class="small center">Microarchitecture description schema provided by Timeloop</figcaption>
    </div>
    <div class="fragment fade-in-then-out" style="display: grid; place-items: center;">
      <img width="30%" src="./figs/quals/timeloop_workload_definition.png" style="margin:0;">
      <figcaption class="small center">Timeloop's schema for defining workloads and their mapping</figcaption>
    </div>
    <div class="fragment fade-in" style="display: grid; place-items: center;">
      <img width="70%" src="./figs/quals/timeloop_outputs.png" style="margin:0;">
      <figcaption class="small center">Timeloop + Accelergy flow. Inputs: workload. Outputs: ML microarchitecture + PPA</figcaption>
    </div>
  </div>

  <div class="fragment">
  <div class="verysmall">
    <p class="footnote" style="margin:0;">
    [1]: Parashar, A., et. al., 2019. Timeloop: A systematic approach to dnn accelerator evaluation. ISPASS.<br/>
    [2]: Wu, Y.N., Emer, J.S. and Sze, V., 2019. Accelergy: An architecture-level energy estimation methodology for accelerator designs. ICCAD.
    </p>
  </div>
  </div>
</section>

<section>
  <h2>Hardware Abstractions: "Rough" uArch Models - Cores</h2>
  <!-- Wattch, CACTI, McPAT (CPU modeling) -->

  <ul class="smallish">
    <li class="fragment">Rough uArch models are also common for evaluating core microarchitectures</li>
    <li class="fragment">Prior Work: McPAT<sup>[1]</sup> models CPUs with a parameterizable out-of-order pipeline and uncore components coupled to a timing simulator. CACTI<sup>[2]</sup> models the PPA of SRAM-based caches and DRAM.</li>
  </ul>

  <div class="center r-stack">
    <div class="fragment fade-in-then-out" style="display: grid; place-items: center;">
      <img width="50%" src="./figs/quals/mcpat_flow.png">
      <figcaption class="small center">The simulation flow provided by McPAT.</figcaption>
    </div>
    <div class="fragment fade-in" style="display: grid; place-items: center;">
      <img width="70%" src="./figs/quals/mcpat_output.png">
      <figcaption class="small center">McPAT results. Inputs: workload and microarch description. Outputs: PPA</figcaption>
    </div>
  </div>

  <div class="fragment">
  <hr>
  <div class="verysmall">
    <p class="footnote" style="margin:0;">
    [1]: Li, S., et. al., 2009. McPAT: An integrated power, area, and timing modeling framework for multicore and manycore architectures. MICRO.<br />
    [2]: Muralimanohar, et al., 2009. CACTI 6.0: A tool to model large caches. HP laboratories.
    </p>
  </div>
  </div>
</section>

<section>
  <h2>Hardware Abstractions: "Detailed" uArch Models - Cores</h2>

  <!-- Modeling precise microarchitectural details usually at cycle-level time-granularity -->
  <!-- Workload type - concrete binary -->

  <ul class="smallish">
    <li class="fragment">The most popular way to evaluate core microarchitectural optimizations is with a detailed execution-driven simulator. Many microarchitectural states are modeled.</li>
    <li class="fragment">Prior Work: gem5, ZSim, SST, MARSSx86, Sniper, ESESC. These simulators model the core pipeline and uncore components with cycle-level time-granularity.</li>
  </ul>

  <div class="center r-stack">
    <div class="fragment fade-in-then-out" style="display: grid; place-items: center;">
      <img width="50%" src="./figs/quals/gem5_architecture.png">
      <figcaption class="small center">The modular architecture of gem5.</figcaption>
    </div>
    <div class="fragment fade-in" style="display: grid; place-items: center;">
      <img width="80%" src="./figs/quals/gem5_kanata_pipeline_viewer.png">
      <figcaption class="small center">Detailed per-instruction core pipeline visualization using Konata.</figcaption>
    </div>
  </div>
</section>

<section>
  <h2>Hardware Abstractions: RTL</h2>

  <ul>
    <li class="fragment">Register-transfer level (RTL) (e.g. Verilog) is the lowest abstraction used in pre-silicon architecture evaluation</li>
    <li class="fragment">Every bit of state and logic is explicitly modeled. RTL is the highest fidelity hardware model.</li>
    <li class="fragment">Can extract very precise power, performance, and area metrics</li>
  </ul>
</section>

<section>
  <h2>Which Hardware Abstraction is Suitable?</h2>

  <ol class="small">
    <li>Architectural (functional) models</li>
    <li>Microarchitectural models (<em>"rough"</em>) with approximate state and timing</li>
    <li>Microarchitectural models (<em>"detailed"</em>) with more refined state and timing</li>
    <li>Register-transfer level (RTL) models with full fidelity state and timing</li>
  </ol>

  <p class="center fragment">Can't compromise on accuracy or latency to enable meaningful and fast microarchitectural iteration.</p>

  <hr class="fragment">

  <p class="center fragment"><strong>"detailed" uArch models</strong> or <strong>RTL</strong> are the only options for our performance simulator selection</p>

</section>

<section>
  <h2>Simulator Metrics</h2>

  <p class="center fragment">Simulation techniques span the gamut on various axes. Each simulation technique assumes <em>a particular hardware abstraction</em>.</p>

  <ul class="smallish">
    <li class="fragment"><strong>Throughput</strong>
      <ul><li>How many instructions can be simulated per real second? (MIPS = millions of instructions per second)</li></ul>
    </li>
    <li class="fragment"><strong>Accuracy</strong>
      <ul><li>Do the output metrics of the simulator match those of the modeled SoC in its real environment?</li></ul>
    </li>
    <li class="fragment"><strong>Startup latency</strong>
      <ul><li>How long does it take from the moment the simulator's parameters/inputs are modified to when the first instruction is executed?</li></ul>
    </li>
    <li class="fragment"><strong>Metric diversity</strong>
      <ul>
        <li>What metrics can the simulator emit?</li>
        <li>This is tied to the hardware abstraction used</li>
      </ul>
    </li>
    <li class="fragment"><strong>Cost</strong>
      <ul>
        <li>What hardware platform does the simulator run on?</li>
        <li>How much does it cost to run a simulation?</li>
      </ul>
    </li>
  </ul>
</section>

<section>
  <!--RTL vs detailed uArch vs arch vs high-level spec

  We will restrict our scope to architectures which already have concrete implementations.
  No need to high-level analytical analysis since we're trying to speed up iteration loop, not discover new accelerator or core architectures.
  This is a separate research direction.-->
  <h2>Existing Hardware Evaluation Techniques</h2>

  <table class="comparison_table">
    <thead><tr>
      <th></th>
      <th>Examples</th>
      <th>Throughput</th>
      <th>Latency</th>
      <th>Accuracy</th>
      <th>Metrics</th>
      <th>Cost</th>
    </tr></thead>
    <tbody>
    <tr class="fragment">
      <td>Analytical Models</td>
      <td>Aladdin, Timeloop</td>
      <td class="bg-green">10-1000 MIPS</td>
      <td class="bg-green">seconds</td>
      <td class="bg-red">Wildly variable</td>
      <td>PPA estimates</td>
      <td class="bg-green">Minimal</td>
    </tr>
    <tr class="fragment">
      <td>Architectural Simulators</td>
      <td>spike, qemu</td>
      <td class="bg-green">10-100+ MIPS</td>
      <td class="bg-green">&lt;1 second</td>
      <td class="bg-red">None</td>
      <td>Commit trace</td>
      <td class="bg-green">Minimal</td>
    </tr>
    <tr class="fragment">
      <td>μArch Simulators</td>
      <td>gem5, Sniper, ZSim, SST</td>
      <td class="bg-orange">100 KIPS (gem5) - 100 MIPS (Sniper)</td>
      <td class="bg-green">&lt;1 minute</td>
      <td class="bg-orange">10-50% IPC error</td>
      <td>Pipeline view / IPC trace</td>
      <td class="bg-green">Minimal</td>
    </tr>
    <tr class="fragment">
      <td>RTL Simulators</td>
      <td>Verilator, VCS, Xcelium</td>
      <td class="bg-red">1-10 KIPS</td>
      <td class="bg-orange">2-10 minutes</td>
      <td class="bg-green">Cycle-exact</td>
      <td>RTL-level traces</td>
      <td class="bg-green">Minimal</td>
    </tr>
    <tr class="fragment">
      <td>FPGA Prototypes</td>
      <td>HAPS, Protium</td>
      <td class="bg-red">≈ 50 MIPS</td>
      <td class="bg-red">2-6 hours</td>
      <td class="bg-green">Cycle-exact</td>
      <td>Subset of RTL signals</td>
      <td class="bg-orange">$10k+</td>
    </tr>
    <tr class="fragment">
      <td>FPGA-Based Emulators</td>
      <td>Firesim</td>
      <td class="bg-green">≈ 10 MIPS</td>
      <td class="bg-red">2-6 hours</td>
      <td class="bg-green">Cycle-exact</td>
      <td>Subset of RTL signals</td>
      <td class="bg-orange">$10k+</td>
    </tr>
    <tr class="fragment">
      <td>ASIC-Based Emulators</td>
      <td>ZeBu, Palladium</td>
      <td class="bg-green">≈ 1-10 MIPS</td>
      <td class="bg-orange">&lt;1 hour</td>
      <td class="bg-green">Cycle-exact</td>
      <td>RTL-level traces</td>
      <td class="bg-red">$10M+</td>
    </tr>
    <tr class="fragment">
      <td>Multi-level Sampled Simulation</td>
      <td><strong>TidalSim</strong></td>
      <td class="bg-green">10+ MIPS</td>
      <td class="bg-green">&lt;1 minute</td>
      <td class="bg-green">&lt;1% IPC error</td>
      <td>Sampled RTL-level traces</td>
      <td class="bg-green">Minimal</td>
    </tr>
    </tbody>
  </table>
  <!-- uArch Perf Sim is nearly there! Can we improve its accuracy or improve its throughput to get us to the golden promise land? -->
</section>

<section>
  <h2>Can we Use Microarchitectural Simulators?</h2>
  <!-- Consider accuracy vs speed tradeoff + implementation complexity tradeoff -->

  <!-- - cite paper on arch sims considered harmful
  Accuracy - discuss why this can't be really improved - need to resort to RTL for fidelity that we can trust (on PPA)
  Throughput - we can use sampling - let's discuss that -->

  <!-- <p class="fragment center">If we can make uArch simulators <strong>faster</strong> (10x off from functional simulators) and <strong>more accurate</strong>, then the problem is solved!</p>-->

  <ul>
    <li class="fragment">uArch simulators seem to satisfy most of our requirements
      <ul>
        <li class="fragment"><strong>Low startup latency</strong>: seconds to 1 minute</li>
        <li class="fragment"><Strong>Metrics</strong>: IPC traces
        <li class="fragment"><strong>Cost</strong>: minimal</li>
      </ul>
    </li>
    <li class="fragment">Can we adapt uArch simulators to perform better in terms of <strong>accuracy</strong> and <strong>throughput</strong>?</li>
  </ul>
</section>

<section>
  <h2>Accuracy of Microarchitectural Simulators</h2>

  <!-- Want to show:
    - simulators are generally inaccurate wrt real hardware first of all
    - simulators disagree with each other a lot
    - simulators poorly model the impact of various uarch changes (pipeline width, cache size, branch predictor)
    - simulators need calibration with silicon to get decent accuracy (which is painful and doesn't prove anything about generalizability)
  -->

  <div class="center r-stack">
    <div class="fragment fade-in-then-out" style="display: grid; place-items: center;">
      <img src="./figs/quals/uarch_simulator_study-ipc.png" />
      <figcaption class="small center">
      Comparison of estimated IPC from various uArch simulators vs real IPC from Haswell.<sup>[1]</sup>
      MAPE on MiBench: 9.5% (Sniper), 44.6% (gem5), 38.2% (PTLSim) and 47.06% (Multi2Sim).
      </figcaption>
    </div>
    <div class="fragment fade-in-then-out" style="display: grid; place-items: center;">
      <img src="./figs/quals/uarch_simulator_study-ipc2.png" />
      <figcaption class="small center">Raw IPC errors on 64-bit workloads<sup>[2]</sup>. Simulators not only disagree with each other, but have substantial errors exceeding 20%.
      </figcaption>
    </div>
    <div class="fragment fade-in-then-out" style="display: grid; place-items: center;">
      <img src="./figs/quals/uarch_simulator_study-pipeline_width.png" />
      <figcaption class="small center">Impact of halving the pipeline width (widths of fetch, decode, issue/rename, dispatch, and commit are halved)<sup>[2]</sup>. Simulators disagree with each other.
      </figcaption>
    </div>
    <div class="fragment fade-in-then-out" style="display: grid; place-items: center;">
      <img src="./figs/quals/uarch_simulator_study-reduced_cache_size.png" />
      <figcaption class="small center">Impact of halving all the cache sizes<sup>[2]</sup>. Note how MARSSx86 shows <em>increased</em> IPC for some benchmarks! Again, disagreements are substantial.
      </figcaption>
    </div>
    <div class="fragment fade-in-then-out" style="display: grid; place-items: center;">
      <img src="./figs/quals/uarch_simulator_study-branch_predictor.png" />
      <figcaption class="small center">Impact of using a bimodal branch predictor vs the Haswell BP.<sup>[2]</sup>. 
      </figcaption>
    </div>
  </div>

  <div class="fragment">
  <hr>
  <div class="verysmall">
    <p class="footnote" style="margin:0;">
    [1]: Akram, A. and Sawalha, L., 2016, October. x86 computer architecture simulators: A comparative study. ICCD.<br />
    [2]: Akram, A. and Sawalha, L., 2019. A survey of computer architecture simulation techniques and tools. IEEE Access
    </p>
  </div>
  </div>
</section>

<section>
  <h2>Flexibility vs Accuracy Tradeoff of uArch Simulators</h2>

  Trends aren't enough - see the sensitivity differences of these simulators! Gradients are critical!

  <blockquote>
Sniper though shows greater accuracy, is not very flexible

to allow one to model new micro-architectural features
compared to gem5. Sniper does not support full-system
simulation and the effect of OS for applications. It is
best use is for x86 many-core user-mode workloads. On
the other hand, gem5 and PTLsim are more flexible and
can be used for studies of particular microarchitectural
blocks, and full-system workloads, with gem5 being more
configurable and showing higher accuracy.
</blockquote>
  <div class="fragment">
  <hr>
  <div class="verysmall">
    <p class="footnote" style="margin:0;">
    [1]: Nowatzki, T., Menon, J., Ho, C.H. and Sankaralingam, K., 2015. Architectural simulators considered harmful. IEEE Micro.
    [2]: Akram, A. and Sawalha, L., 2016, October. x86 computer architecture simulators: A comparative study. ICCD.
    </p>
  </div>
  </div>
</section>

<section>
  <h2>Selection of Simulators</h2>
  We want to use RTL simulation as the lowest level performance simulator. But we also want to have enough throughput! How???

  Let's learn from sampled simulation approaches previously explored by 
</section>

<section>
  <h2>Phase Behavior of Programs</h2>

  <div class="container">
  <div>
  <ul style="font-size:95%">
    <li class="fragment" data-fragment-index="1">Program execution traces aren’t random
      <ul class="fragment" data-fragment-index="2">
        <li>They execute the same code again-and-again</li>
        <li>Application execution traces can be split into <strong style="text-decoration:underline;">phases</strong> that exhibit similar μArch behavior</li>
      </ul>
    </li>
    <li class="fragment" data-fragment-index="4">Prior work: SimPoint
      <ul class="fragment" data-fragment-index="5">
        <li>Identify basic blocks executed in a given interval (e.g. 1M instruction intervals)</li>
        <li>Embed each interval using their ‘basic block vector’</li>
        <li>Cluster intervals using k-means</li>
      </ul>
    </li>
    <li class="fragment" data-fragment-index="6">Similar intervals → similar μArch behaviors
      <ul class="fragment" data-fragment-index="7"><li>Only execute unique intervals in low-level RTL simulation!</li></ul>
    </li>
  </ul>
  </div>
  <div class="fragment" data-fragment-index="3" style="display:grid; align-content: center; justify-items:center;">
    <img src="./figs/multi-level-sim/simpoint-gzip_phases.gif" />
    <img src="./figs/multi-level-sim/simpoint-gcc_phases.gif" />
  </div>
  </div>
</section>

<section>
  <h2>Prior Work</h2>

  <ul>
    <li class="fragment"><em>Sampled</em> simulation techniques have been used in μArch simulators for decades
      <ul>
        <li class="fragment">SimPoint-style sampling (interval clustering, large intervals)</li>
        <li class="fragment">SMARTs-style sampling (reservoir sampling, small intervals)</li>
        <li class="fragment">Implemented in gem5, Sniper, ZSim, SST</li>
      </ul>
    </li>
    <li class="fragment">LiveSim proposed 2-level simulation (ISA → μArch sim) for rapid iteration of μArch parameters
      <ul>
        <li>Functional warmup was used for the cache and branch predictor models</li>
      </ul>
    </li>
  </ul>
</section>

<!--
  - need high accuracy: we must use uArch/RTL as abstraction
  - uarch/RTL necessitates: we must use then uarch or rtl sim
  - uarch sim is inaccurate: we must use rtl sim
  - rtl sim is slow: so what can we do about it?
  - so we must use some kind of sampled rtl sim with functional uarch warmup models ganged with a functional isa model
-->
